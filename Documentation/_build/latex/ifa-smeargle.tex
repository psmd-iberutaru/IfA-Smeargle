%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Usage and Operation:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{IfA-Smeargle}
\date{Sep 03, 2019}
\release{2019-08-19}
\author{Sparrow}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Quickstart}
\label{\detokenize{quickstart:quickstart}}\label{\detokenize{quickstart::doc}}
It is important that it is made clear that this is a module and a collection
of scripts more than a fully packaged program. To attempt to use it as such
may be a bit hard.

Nevertheless, this page guides one on how to use IfA-Smeargle for the
reduction and analysis of their detector data.


\section{Installation}
\label{\detokenize{quickstart:installation}}
Installing IfA-Smeargle is not too difficult. It is a Python module like any
other. Its source can be downloaded from the appropriate \sphinxhref{https://github.com/psmd-iberutaru/IfA-Smeargle}{GitHub IfA-Smeargle
link}.

The entire directory is filled with other files not quite associated
with the module itself. (These files are still needed for historical and
development purposes.) The directory/folder labeled \sphinxcode{\sphinxupquote{IfA\_Smeargle}} is the
module code itself. It can be imported like any other same directory module
(via \sphinxcode{\sphinxupquote{import IfA\_Smeargle as ifas}}, as suggested).


\section{Pipelines, Data Directories, and Configuration Files/Classes}
\label{\detokenize{quickstart:pipelines-data-directories-and-configuration-files-classes}}
IfA-Smeargle reduction methods are not too difficult. However,
three elements must be clearly understood for proper usage. In general, they
are not too complicated.


\subsection{Pipelines}
\label{\detokenize{quickstart:pipelines}}
Pipelines is simply an instructional list of what should be executed, in
what order and to what quantity. Not every reduction functionality that
IfA-Smeargle provided is needed for every data set. It is important that
the proper pipeline is picked for the right data set.

Every and all built-in pipelines, by design, can be found in the ZULU line
(module documentation can be found here:
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.zulu::doc}]{\sphinxcrossref{\DUrole{doc}{ZULU documentation}}}}.

Also, all built-in pipelines require 2 and only 2 positional parameters,
usually structured as such:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pipeline}\PYG{p}{(}\PYG{n}{data\PYGZus{}directory}\PYG{p}{,} \PYG{n}{configuration\PYGZus{}class}\PYG{p}{)}
\end{sphinxVerbatim}

This is intentional, and any development towards new proposed built-in
pipelines should also adhere to this format.


\subsection{Data Directories}
\label{\detokenize{quickstart:data-directories}}
Data directories are most likely the easiest to understand. They are basically
strings to where the data is being stored. It is generally the design of
every pipeline that it adapts their document renaming and processing to raw
data right out of the appropriate detector. Therefore, modification of raw
data or its file/file-structure is generally unneeded.

To feed a pipeline the proper data directory, just send it an absolute or
relative (suggested) path to the data itself as a UNIX string path. Any
built-in pipeline should be able to handle itself afterwards.


\subsection{Configuration Files/Classes}
\label{\detokenize{quickstart:configuration-files-classes}}
Configuration files/classes are different and a bit more complex. It is a
general principle of IfA-Smeargle that any and all customization or
parameters to any reduction functions are contained in a configuration
file/class.

A configuration file just stores a configuration class; all configuration files
have the \sphinxcode{\sphinxupquote{.ifaspkl}} file extension. IfA-Smeargle is hard-coded to reject
any file without such extension and to always write configuration classes
with such extension. Do not rename any file not made by IfA-Smeargle with
such file extension.

In order to make a configuration file, please use the Jupyter notebook labeled
\sphinxcode{\sphinxupquote{ifas\_configuration\_recipe.ipynb}}. This writes a configuration file as
specified.

\begin{sphinxadmonition}{warning}{Warning:}
Configuration files and classes are not forward compatible. There
is however a function to convert older configuration classes/files to newer
versions while preserving the old data. See the {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_functions:IfA_Smeargle.yankee.yankee_functions.fast_forward_configuration_class}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fast Forward Configuration Class}}}}} function.
\end{sphinxadmonition}


\section{Executing Pipelines}
\label{\detokenize{quickstart:executing-pipelines}}
We are all well and good now; having learned the three basic elements of this
module. The only thing left is to combine them into one call so that the
pipeline will run on the data within the data directory in accordance to
parameters set by the configuration file. There are currently three ways
(really two ways) that this can be done. Listed below are the three primary
and suggested ways that pipelines should be executed.


\subsection{Jupyter Notebook}
\label{\detokenize{quickstart:jupyter-notebook}}
Jupyter notebook is very helpful in sectioning off code and running it
individually. It is currently the suggested of the three equally valid ways
to execute a pipeline.

Like any other Python module, IfA-Smeargle can be imported as a local module
into the Jupyter notebook Python script using \sphinxcode{\sphinxupquote{import IfA\_Smeargle as ifas}}
(as per Python imports, the \sphinxcode{\sphinxupquote{ifas}} isn’t needed, but it is the suggested
abbreviation for this module.) Please note that this is local import rather
than a package import. Feel free to add this module into your Python package
directory at your own risk.

You can then load your configuration files as one would load normal files in
Jupyter notebook via the YANKEE line; then run built-in pipelines found in the
ZULU line like normal function call.

To load a configuration file and have it be a configuration class, the simplest
way is likely to invoke the following function call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{config\PYGZus{}class} \PYG{o}{=} \PYG{n}{ifas}\PYG{o}{.}\PYG{n}{yankee}\PYG{o}{.}\PYG{n}{SmeargleConfig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{path/to/ifas\PYGZus{}config.ifaspkl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

To execute a pipeline, as they are generally stored in ZULU, calling them
from there is the suggested way to do it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{ifas}\PYG{o}{.}\PYG{n}{zulu}\PYG{o}{.}\PYG{n}{pipelines}\PYG{o}{.}\PYG{n}{pipeline\PYGZus{}name}\PYG{p}{(}\PYG{n}{data\PYGZus{}directory}\PYG{p}{,} \PYG{n}{configuration\PYGZus{}class}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Python Interactive Session}
\label{\detokenize{quickstart:python-interactive-session}}
This is not too different from Jupyter notebook method. In a similar vein to
the Jupyter notebook scheme, IfA-Smeargle can be imported into an interactive
session or a full-fledged Python script using \sphinxcode{\sphinxupquote{import IfA\_Smeargle as ifas}}
(while obeying local import rules, unless in package path directory).

From that point on, as it is within a Python session (like Jupyter notebook),
to call pipelines and load configuration files and execute them as needed.

See {\hyperref[\detokenize{quickstart:jupyter-notebook}]{\sphinxcrossref{Jupyter Notebook}}} for more information on how to use IfA-Smeargle within
Python environment.


\subsection{Command-line Call}
\label{\detokenize{quickstart:command-line-call}}
It is common for Python scripts to be run from from the command-line interface.
As such, this module allows pipelines to be run from a command-line interface
via \sphinxcode{\sphinxupquote{ifas\_execute.py}}.

The command-call for \sphinxcode{\sphinxupquote{ifas\_execute.py}} must be done within the same directory
as the Python file, or one parent directory above it. It will likely be unable
to import local directories if it is executed outside of these areas. The
data directory and configuration file directory paths should not have theses
restrictions.

All command-line calls will likely be in a format similar to the one below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{ifas\PYGZus{}execute}\PYG{o}{.}\PYG{n}{py} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pipeline\PYGZus{}name}\PYG{l+s+s1}{\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data\PYGZus{}directory}\PYG{l+s+s1}{\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{configuration\PYGZus{}file}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

Note that all parameters should be strings which contain the paths (on in the
case of \sphinxcode{\sphinxupquote{pipeline\_name}}, the exact name of the pipeline itself.) There is
an optional silent flag (\sphinxcode{\sphinxupquote{-s}} or \sphinxcode{\sphinxupquote{-{-}silent}}), it defaults to False.


\chapter{IfA\_Smeargle}
\label{\detokenize{python_docstrings/modules:ifa-smeargle}}\label{\detokenize{python_docstrings/modules::doc}}

\section{IfA\_Smeargle package}
\label{\detokenize{python_docstrings/IfA_Smeargle:ifa-smeargle-package}}\label{\detokenize{python_docstrings/IfA_Smeargle::doc}}

\subsection{Subpackages}
\label{\detokenize{python_docstrings/IfA_Smeargle:subpackages}}

\subsubsection{IfA\_Smeargle.bravo package}
\label{\detokenize{python_docstrings/IfA_Smeargle.bravo:ifa-smeargle-bravo-package}}\label{\detokenize{python_docstrings/IfA_Smeargle.bravo::doc}}

\paragraph{Submodules}
\label{\detokenize{python_docstrings/IfA_Smeargle.bravo:submodules}}

\subparagraph{IfA\_Smeargle.bravo.archiving module}
\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.archiving:module-IfA_Smeargle.bravo.archiving}}\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.archiving:ifa-smeargle-bravo-archiving-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.archiving::doc}}\index{IfA\_Smeargle.bravo.archiving (module)@\spxentry{IfA\_Smeargle.bravo.archiving}\spxextra{module}}
The purpose of this file is to contain all of the data conservation methods
that are used to ensure that modifications to data do not harm the original
data. Of course, the usage of these methods usually involve creating a
copy of data. The usage of these functions are optional.
\index{duplicate\_archive\_data\_files() (in module IfA\_Smeargle.bravo.archiving)@\spxentry{duplicate\_archive\_data\_files()}\spxextra{in module IfA\_Smeargle.bravo.archiving}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.archiving:IfA_Smeargle.bravo.archiving.duplicate_archive_data_files}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.bravo.archiving.}}\sphinxbfcode{\sphinxupquote{duplicate\_archive\_data\_files}}}{\emph{data\_directory}, \emph{archive\_extension='bztar'}}{}
Creates a file archive of a copy of the data files contained within a
directory.

This function creates an archive of a data directory, preserving a copy
of data. However, note that this function generally takes a bit of time
if there are a lot of files or if the files are particularly large.

Please note that this function archives recursively. Non-data files and
non-required files should not be in the a given Data directory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The directory that the data is contained within.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{archive\_extension}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The extension of the archive. Note that only some archives are
supported. Default is \sphinxcode{\sphinxupquote{bztar}}.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.bravo.averaging module}
\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.averaging:module-IfA_Smeargle.bravo.averaging}}\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.averaging:ifa-smeargle-bravo-averaging-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.averaging::doc}}\index{IfA\_Smeargle.bravo.averaging (module)@\spxentry{IfA\_Smeargle.bravo.averaging}\spxextra{module}}\index{average\_endpoints() (in module IfA\_Smeargle.bravo.averaging)@\spxentry{average\_endpoints()}\spxextra{in module IfA\_Smeargle.bravo.averaging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.averaging:IfA_Smeargle.bravo.averaging.average_endpoints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.bravo.averaging.}}\sphinxbfcode{\sphinxupquote{average\_endpoints}}}{\emph{fits\_file}, \emph{start\_chunk}, \emph{end\_chunk}, \emph{write\_file=True}, \emph{alternate\_name=None}}{}
This function reads a fits file and computes its end section values.

This function reads in a fits file of 3 dimensions, averaging some
top chunk and bottom chunk of their “temporal” axis.

If there is no temporal axis, this program raises an error.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fits\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{Astropy HDUList file}}) \textendash{} This is the fits file that will be modified, or at least have its
values calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{start\_chunk}} (\sphinxstyleliteralemphasis{\sphinxupquote{array-like}}) \textendash{} The exact range of frames from the beginning that will be median-ed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{end\_chunk}} (\sphinxstyleliteralemphasis{\sphinxupquote{array-like}}) \textendash{} The exact range of frames from the bottom that will be median-ed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{write\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If true, the Astropy HDUL object is written to a fits file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alternate\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} An alternate fits file name to write the data too instead of the
first provided one.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{hdu\_file} \textendash{} The HDUList object of the written file.

\item[{Return type}] \leavevmode
Astropy HDUList file

\end{description}\end{quote}

\end{fulllineitems}

\index{average\_endpoints\_per\_kilosecond() (in module IfA\_Smeargle.bravo.averaging)@\spxentry{average\_endpoints\_per\_kilosecond()}\spxextra{in module IfA\_Smeargle.bravo.averaging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.averaging:IfA_Smeargle.bravo.averaging.average_endpoints_per_kilosecond}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.bravo.averaging.}}\sphinxbfcode{\sphinxupquote{average\_endpoints\_per\_kilosecond}}}{\emph{fits\_file}, \emph{start\_chunk}, \emph{end\_chunk}, \emph{frame\_exposure\_time}, \emph{write\_file=True}, \emph{alternate\_name=None}}{}
This function reads a fits file and computes its end section values.

This function reads in a fits file of 3 dimensions, averaging some
top chunk and bottom chunk of their “temporal” axis, normalizing
and dividing over a timespan. The time is measured in kilo-seconds. This
is basically a wrapper function around the per second version.

If there is no temporal axis, this program raises an error.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fits\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{Astropy HDUList file}}) \textendash{} This is the fits file that will be modified, or at least have its
values calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{start\_chunk}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The exact number of frames from the beginning that will be median-ed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{end\_chunk}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The exact number of frames from the bottom that will be median-ed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{frame\_exposure\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The duration, per frame (in seconds), of each exposure.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{write\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If true, the Astropy HDUL object is written to a fits file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alternate\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} An alternate fits file name to write the data too instead of the
first provided one.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{hdu\_file} \textendash{} The HDUList object of the written file.

\item[{Return type}] \leavevmode
Astropy HDUList file

\end{description}\end{quote}

\end{fulllineitems}

\index{average\_endpoints\_per\_second() (in module IfA\_Smeargle.bravo.averaging)@\spxentry{average\_endpoints\_per\_second()}\spxextra{in module IfA\_Smeargle.bravo.averaging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.averaging:IfA_Smeargle.bravo.averaging.average_endpoints_per_second}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.bravo.averaging.}}\sphinxbfcode{\sphinxupquote{average\_endpoints\_per\_second}}}{\emph{fits\_file}, \emph{start\_chunk}, \emph{end\_chunk}, \emph{frame\_exposure\_time}, \emph{write\_file=True}, \emph{alternate\_name=None}}{}
This function reads a fits file and computes its end section values.

This function reads in a fits file of 3 dimensions, averaging some
top chunk and bottom chunk of their “temporal” axis, normalizing
and dividing over a timespan.

If there is no temporal axis, this program raises an error.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fits\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{Astropy HDUList file}}) \textendash{} This is the fits file that will be modified, or at least have its
values calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{start\_chunk}} (\sphinxstyleliteralemphasis{\sphinxupquote{array-like}}) \textendash{} The exact range of frames from the beginning that will be median-ed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{end\_chunk}} (\sphinxstyleliteralemphasis{\sphinxupquote{array-like}}) \textendash{} The exact range of frames from the bottom that will be median-ed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{frame\_exposure\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The duration, per frame (in seconds), of each exposure.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{write\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If true, the Astropy HDUL object is written to a fits file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alternate\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} An alternate fits file name to write the data too instead of the
first provided one.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{hdu\_file} \textendash{} The HDUList object of the written file.

\item[{Return type}] \leavevmode
Astropy HDUList file

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.bravo.bravo\_main module}
\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.bravo_main:module-IfA_Smeargle.bravo.bravo_main}}\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.bravo_main:ifa-smeargle-bravo-bravo-main-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.bravo_main::doc}}\index{IfA\_Smeargle.bravo.bravo\_main (module)@\spxentry{IfA\_Smeargle.bravo.bravo\_main}\spxextra{module}}
Contains all of the methods used for renaming and reformatting data.

Each function is dependent on the array and/or method. Only one function
should ever be used for any one given process.
\index{bravo\_execution\_saphira() (in module IfA\_Smeargle.bravo.bravo\_main)@\spxentry{bravo\_execution\_saphira()}\spxextra{in module IfA\_Smeargle.bravo.bravo\_main}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.bravo_main:IfA_Smeargle.bravo.bravo_main.bravo_execution_saphira}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.bravo.bravo\_main.}}\sphinxbfcode{\sphinxupquote{bravo\_execution\_saphira}}}{\emph{data\_directory}, \emph{configuration\_class}}{}
Reformats data provided by a SAPHIRA array into a form used by this
program.

Each array or data set has their own different forms of representing the
data that has been collected. The purpose of this, and other modules, is
to reformat and restructure the data collected into a more useful form
for this program.

The function automatically reformats the directories.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that is to processed and filtered accordingly

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{configuration\_class}} ({\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:IfA_Smeargle.yankee.yankee_main.SmeargleConfig}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{SmeargleConfig}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{BravoConfig class}}) \textendash{} The configuration class that will be used to provide instruction
to the ECHO filters.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.bravo.renaming module}
\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.renaming:module-IfA_Smeargle.bravo.renaming}}\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.renaming:ifa-smeargle-bravo-renaming-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.renaming::doc}}\index{IfA\_Smeargle.bravo.renaming (module)@\spxentry{IfA\_Smeargle.bravo.renaming}\spxextra{module}}
This file contains methods used to determine proper naming conventions and
to reformat the fits file names from raw output  (often just timestamps) to
something more useful and accurate to the data.
\index{parallel\_renaming() (in module IfA\_Smeargle.bravo.renaming)@\spxentry{parallel\_renaming()}\spxextra{in module IfA\_Smeargle.bravo.renaming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.renaming:IfA_Smeargle.bravo.renaming.parallel_renaming}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.bravo.renaming.}}\sphinxbfcode{\sphinxupquote{parallel\_renaming}}}{\emph{file\_names}, \emph{file\_renames}, \emph{data\_directory=None}, \emph{file\_extensions='.fits'}}{}
Renames files provided parallel name arrays.

Given two same length lists of file names, one pre-rename and one
post-rename, this function renames them accordingly. A directory is also
an option, and the file name list will be derived from that.

This only works for one type of file extension, or leave the string blank
for all files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_names}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The list of the file names that is to be renamed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_renames}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The list of the file names that are going to be used for the renaming
process.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} A directory that contains all of the files that are going to be
renamed. Does not handle directories recursively.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_extensions}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The file extension of the files that are going to be renamed. Defaults
to a .fits file.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{voltage\_pattern\_rename\_fits() (in module IfA\_Smeargle.bravo.renaming)@\spxentry{voltage\_pattern\_rename\_fits()}\spxextra{in module IfA\_Smeargle.bravo.renaming}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.bravo.renaming:IfA_Smeargle.bravo.renaming.voltage_pattern_rename_fits}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.bravo.renaming.}}\sphinxbfcode{\sphinxupquote{voltage\_pattern\_rename\_fits}}}{\emph{data\_directory}, \emph{voltage\_pattern}, \emph{begin\_garbage=0}, \emph{common\_prefix=''}, \emph{common\_suffix=''}, \emph{rename=False}, \emph{archive\_data=True}}{}
Renames files according to their voltage pattern specified.

Some data filename outputs only give timestamps. This function renames

The output files created are according to the voltage pattern that the
user specified. This function assumes that the pattern provided is one
‘set’, where a set contains some amount of fits files. Moreover, this
function weakly determines which are up-mid-down ramps.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} This is the directory that contain all of the data files to be
renamed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{voltage\_pattern}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} These are voltage values, assuming that the first element is the
first voltage element to be used, proceeding from there in order.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{begin\_garbage}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The number of files, in the beginning, that should not count as data.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{common\_prefix}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} All file renames will contain this prefix before the voltage data.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{common\_suffix}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} All file renames will contain this suffix after the voltage data.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rename}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If true, the program renames the files as specified, else, it leaves
the files untouched; still archived, however, if \sphinxcode{\sphinxupquote{copy\_data=True}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{archive\_data}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Execute the renaming on a copy of the data, the original data
is archived and preserved.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{voltage\_string\_list} \textendash{} This is the list of the voltage strings applied, given in a parallel
ordered form. Does not include prefixes/suffixes.

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{python_docstrings/IfA_Smeargle.bravo:module-IfA_Smeargle.bravo}}\label{\detokenize{python_docstrings/IfA_Smeargle.bravo:module-contents}}\index{IfA\_Smeargle.bravo (module)@\spxentry{IfA\_Smeargle.bravo}\spxextra{module}}

\subsubsection{IfA\_Smeargle.echo package}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo:ifa-smeargle-echo-package}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo::doc}}

\paragraph{Subpackages}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo:subpackages}}

\subparagraph{IfA\_Smeargle.echo.masks package}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks:ifa-smeargle-echo-masks-package}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks::doc}}

\subparagraph{Submodules}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks:submodules}}

\subparagraph{IfA\_Smeargle.echo.masks.masks\_echo000 module}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo000:module-IfA_Smeargle.echo.masks.masks_echo000}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo000:ifa-smeargle-echo-masks-masks-echo000-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo000::doc}}\index{IfA\_Smeargle.echo.masks.masks\_echo000 (module)@\spxentry{IfA\_Smeargle.echo.masks.masks\_echo000}\spxextra{module}}
This file contains the code to calculate which pixel should be masked. Note the masking code
in this file is 000; this file only contains ECHO-000 class masks.
\index{echo010\_fixing\_invalids() (in module IfA\_Smeargle.echo.masks.masks\_echo000)@\spxentry{echo010\_fixing\_invalids()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo000}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo000:IfA_Smeargle.echo.masks.masks_echo000.echo010_fixing_invalids}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo000.}}\sphinxbfcode{\sphinxupquote{echo010\_fixing\_invalids}}}{\emph{data\_array}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This filter applies a mask to all numerically invalid inputs on a programing side.

Numbers that are usually infinite or some other nonsensical quantity serve no real usage in
calculations further downstream. Therefore, they are masked here.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be added to the
dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary entry) will be
returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False) will be added to
the mask dictionary under the key \sphinxcode{\sphinxupquote{echo010\_fixing\_invalids}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.echo.masks.masks\_echo100 module}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo100:module-IfA_Smeargle.echo.masks.masks_echo100}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo100:ifa-smeargle-echo-masks-masks-echo100-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo100::doc}}\index{IfA\_Smeargle.echo.masks.masks\_echo100 (module)@\spxentry{IfA\_Smeargle.echo.masks.masks\_echo100}\spxextra{module}}
This file contains the code to calculate which pixel should be masked. Note the masking code
in this file is 100; this file only contains ECHO-100 class masks.
\index{echo120\_subarray\_mask() (in module IfA\_Smeargle.echo.masks.masks\_echo100)@\spxentry{echo120\_subarray\_mask()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo100}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo100:IfA_Smeargle.echo.masks.masks_echo100.echo120_subarray_mask}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo100.}}\sphinxbfcode{\sphinxupquote{echo120\_subarray\_mask}}}{\emph{data\_array}, \emph{x\_range}, \emph{y\_range}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This applies a mask on the entire array except for a single sub-array
rectangle.

This function subsets a sub-array of the data array from a mask. Only one
sub-array can be defined using this function. The bounds of the sub-array
is inclusively defined by the x-ranges and y-ranges.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The inclusive x-range bounds of the sub-array.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The inclusive y-range bounds of the sub-array.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be
added to the dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary
entry) will be returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid
(False) will be added to the mask dictionary under the
key \sphinxcode{\sphinxupquote{echo120\_subarray\_mask}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{echo170\_gaussian\_truncation() (in module IfA\_Smeargle.echo.masks.masks\_echo100)@\spxentry{echo170\_gaussian\_truncation()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo100}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo100:IfA_Smeargle.echo.masks.masks_echo100.echo170_gaussian_truncation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo100.}}\sphinxbfcode{\sphinxupquote{echo170\_gaussian\_truncation}}}{\emph{data\_array}, \emph{sigma\_multiple}, \emph{bin\_size}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This applies a mask on pixel values outside some Gaussian profile.

This function is similar to echo277\_sigma\_truncation, but instead the
mean and standard deviation are calculating using histogram methods
rather than absolute analysis. Because of the dependence on fits, this
method may be unstable.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sigma\_multiple}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The multiple of sigma from the mean that will be allowed; all else are
masked.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bin\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The size of the bins to use for the histogram fitting.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be
added to the dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary
entry) will be returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid
(False) will be added to the mask dictionary under the
key \sphinxcode{\sphinxupquote{echo170\_gaussian\_truncation}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.echo.masks.masks\_echo200 module}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo200:module-IfA_Smeargle.echo.masks.masks_echo200}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo200:ifa-smeargle-echo-masks-masks-echo200-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo200::doc}}\index{IfA\_Smeargle.echo.masks.masks\_echo200 (module)@\spxentry{IfA\_Smeargle.echo.masks.masks\_echo200}\spxextra{module}}
This file contains the code to calculate which pixel should be masked. Note the masking code
in this file is 200; this file only contains ECHO-200 class masks.
\index{echo270\_minimum\_cut() (in module IfA\_Smeargle.echo.masks.masks\_echo200)@\spxentry{echo270\_minimum\_cut()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo200}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo200:IfA_Smeargle.echo.masks.masks_echo200.echo270_minimum_cut}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo200.}}\sphinxbfcode{\sphinxupquote{echo270\_minimum\_cut}}}{\emph{data\_array}, \emph{minimum\_value}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This applies a mask on all pixels lower than some value.

As the name implies, this function masks all pixels with some value
strictly lower than some minimum value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{minimum\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The minimum value that the filter references.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be
added to the dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary
entry) will be returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False)
will be added to the mask dictionary under the key
\sphinxcode{\sphinxupquote{echo270\_minimum\_cut}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{echo271\_maximum\_cut() (in module IfA\_Smeargle.echo.masks.masks\_echo200)@\spxentry{echo271\_maximum\_cut()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo200}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo200:IfA_Smeargle.echo.masks.masks_echo200.echo271_maximum_cut}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo200.}}\sphinxbfcode{\sphinxupquote{echo271\_maximum\_cut}}}{\emph{data\_array}, \emph{maximum\_value}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This applies a mask on all pixels lower than some value.

As the name implies, this function masks all pixels with some value
strictly higher than some maximum value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{maximum\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The maximum value that the filter references.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be
added to the dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary
entry) will be returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False)
will be added to the mask dictionary under the key
\sphinxcode{\sphinxupquote{echo271\_maximum\_cut}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{echo275\_pixel\_truncation() (in module IfA\_Smeargle.echo.masks.masks\_echo200)@\spxentry{echo275\_pixel\_truncation()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo200}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo200:IfA_Smeargle.echo.masks.masks_echo200.echo275_pixel_truncation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo200.}}\sphinxbfcode{\sphinxupquote{echo275\_pixel\_truncation}}}{\emph{data\_array}, \emph{top\_count}, \emph{bottom\_count}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This filter truncates the top and bottom number of pixels provided.

The values \sphinxcode{\sphinxupquote{top\_count}} and \sphinxcode{\sphinxupquote{bottom\_count}} notate the number of pixels
from top and bottom of the data array  (in value) that should be cut.
The pixels masked are independent on the previous masks applied.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{top\_count}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of pixels from the top (highest value ) of the array
that is to be masked.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bottom\_count}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of pixels from the bottom (lowest value) of the array that
is to be masked.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be
added to the dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary
entry) will be returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False)
will be added to the mask dictionary under the key
\sphinxcode{\sphinxupquote{echo275\_pixel\_truncation}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{echo276\_percent\_truncation() (in module IfA\_Smeargle.echo.masks.masks\_echo200)@\spxentry{echo276\_percent\_truncation()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo200}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo200:IfA_Smeargle.echo.masks.masks_echo200.echo276_percent_truncation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo200.}}\sphinxbfcode{\sphinxupquote{echo276\_percent\_truncation}}}{\emph{data\_array}, \emph{kept\_range}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This filter truncates the top and bottom percent of pixels from the
data array.

The parameter \sphinxcode{\sphinxupquote{kept\_range}} define the percent range of pixels that will
be kept. Anything outside this percentage range is masked. The pixels
the previous masked are independent of masks provided.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kept\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array-like}}) \textendash{} This is the percentage span that will be kept, the rest will be
masked. Percentages are expected to be less than 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be
added to the dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary
entry) will be returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False)
will be added to the mask dictionary under the key
\sphinxcode{\sphinxupquote{echo276\_percent\_truncation}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{echo277\_sigma\_truncation() (in module IfA\_Smeargle.echo.masks.masks\_echo200)@\spxentry{echo277\_sigma\_truncation()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo200}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo200:IfA_Smeargle.echo.masks.masks_echo200.echo277_sigma_truncation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo200.}}\sphinxbfcode{\sphinxupquote{echo277\_sigma\_truncation}}}{\emph{data\_array}, \emph{sigma\_limits}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This applies a mask on pixels outside a given multiple of a sigma
value.

This function masks values if they are outsize of a sigma range from the
mean. The mean and sigma values are automatically calculated from the
array provided.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sigma\_limits}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The multiple of sigma which will be applied. Unequal bottom-top bounds
may be set as a list-like input.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be
added to the dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary
entry) will be returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False)
will be added to the mask dictionary under the key
\sphinxcode{\sphinxupquote{echo277\_sigma\_truncation}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.echo.masks.masks\_echo300 module}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo300:module-IfA_Smeargle.echo.masks.masks_echo300}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo300:ifa-smeargle-echo-masks-masks-echo300-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo300::doc}}\index{IfA\_Smeargle.echo.masks.masks\_echo300 (module)@\spxentry{IfA\_Smeargle.echo.masks.masks\_echo300}\spxextra{module}}
This file contains the code to calculate which pixel should be masked. Note the masking code
in this file is 300; this file only contains ECHO-300 class masks.
\index{echo380\_single\_pixels() (in module IfA\_Smeargle.echo.masks.masks\_echo300)@\spxentry{echo380\_single\_pixels()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo300}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo300:IfA_Smeargle.echo.masks.masks_echo300.echo380_single_pixels}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo300.}}\sphinxbfcode{\sphinxupquote{echo380\_single\_pixels}}}{\emph{data\_array}, \emph{pixel\_list}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This applies a single mask on a single pixel(s)

As the name implies, this function masks a single pixel value or a list of single pixel
pairs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pixel\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{array-like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} This is a list/array of pixel pair (x,y) values. The function loops and applies the
mask to each pair.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be added to the
dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary entry) will be
returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False) will be added to
the mask dictionary under the key \sphinxcode{\sphinxupquote{echo380single\_pixels}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{echo381\_rectangle\_mask() (in module IfA\_Smeargle.echo.masks.masks\_echo300)@\spxentry{echo381\_rectangle\_mask()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo300}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo300:IfA_Smeargle.echo.masks.masks_echo300.echo381_rectangle_mask}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo300.}}\sphinxbfcode{\sphinxupquote{echo381\_rectangle\_mask}}}{\emph{data\_array}, \emph{x\_ranges}, \emph{y\_ranges}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This mask function applies rectangular masks to the data array.

The rectangles defined by subsequent xy-ranges (0-indexed) are masked. Multiple overlapping
rectangles may be defined and masked using this function. The rectangle bounds provided are
also masked as the rectangle is inclusive of said bounds.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_ranges}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The list of 0-indexed x\_ranges to be masked. Must be the same length as y\_ranges.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_ranges}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The list of 0-indexed y\_ranges to be masked. Must be the same length as x\_ranges.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be added to the
dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary entry) will be
returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False) will be added to
the mask dictionary under the key \sphinxcode{\sphinxupquote{echo381\_rectangle\_mask}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{echo382\_column\_mask() (in module IfA\_Smeargle.echo.masks.masks\_echo300)@\spxentry{echo382\_column\_mask()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo300}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo300:IfA_Smeargle.echo.masks.masks_echo300.echo382_column_mask}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo300.}}\sphinxbfcode{\sphinxupquote{echo382\_column\_mask}}}{\emph{data\_array}, \emph{column\_list}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This applies a column mask on the data array provided its locations.

The column mask takes a list of column numbers (0-indexed x-axis values). All pixels within
these columns are then masked.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{column\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The list of column x-axis values that will be masked. Should be 0-indexed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be added to the
dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary entry) will be
returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False) will be added to
the mask dictionary under the key \sphinxcode{\sphinxupquote{echo382\_column\_mask}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{echo383\_row\_mask() (in module IfA\_Smeargle.echo.masks.masks\_echo300)@\spxentry{echo383\_row\_mask()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo300}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo300:IfA_Smeargle.echo.masks.masks_echo300.echo383_row_mask}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo300.}}\sphinxbfcode{\sphinxupquote{echo383\_row\_mask}}}{\emph{data\_array}, \emph{row\_list}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This applies a row mask on the data array provided its locations.

The row mask takes a list of column numbers (0-indexed x-axis values). All pixels within
these rows are then masked.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{row\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The list of row y-axis values that will be masked. Should be 0-indexed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be added to the
dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary entry) will be
returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False) will be added to
the mask dictionary under the key \sphinxcode{\sphinxupquote{echo383\_row\_mask}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{echo398\_nothing() (in module IfA\_Smeargle.echo.masks.masks\_echo300)@\spxentry{echo398\_nothing()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo300}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo300:IfA_Smeargle.echo.masks.masks_echo300.echo398_nothing}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo300.}}\sphinxbfcode{\sphinxupquote{echo398\_nothing}}}{\emph{data\_array}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This applies a blanket blank (all pixels are valid) mask on the data array.

As the name says, this applies a mask…to…well…nothing. As such, all that is
returned in the mask dictionary is the blank mask.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be added to the
dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary entry) will be
returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False) will be added to
the mask dictionary under the key \sphinxcode{\sphinxupquote{echo398\_nothing}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{echo399\_everything() (in module IfA\_Smeargle.echo.masks.masks\_echo300)@\spxentry{echo399\_everything()}\spxextra{in module IfA\_Smeargle.echo.masks.masks\_echo300}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks.masks_echo300:IfA_Smeargle.echo.masks.masks_echo300.echo399_everything}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.masks.masks\_echo300.}}\sphinxbfcode{\sphinxupquote{echo399\_everything}}}{\emph{data\_array}, \emph{previous\_mask=\{\}}, \emph{return\_mask=False}}{}
This applies a blanket blank (all pixels are invalid) mask on the data array.

As the name says, this applies a mask…to…well…everything. As such, all that is
returned in the mask dictionary is the full mask.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data array that the mask will be calculated from.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{previous\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Any previous masks done. The new mask made in this function will be added to the
dictionary. Default is to make a new mask dictionary.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If this is true, then the mask itself (rather than the dictionary entry) will be
returned instead.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_mask} \textendash{} A boolean array for pixels that are masked (True) or are valid (False) will be added to
the mask dictionary under the key \sphinxcode{\sphinxupquote{echo399\_everything}}.

\item[{Return type}] \leavevmode
ndarray -\textgreater{} dictionary

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{Module contents}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks:module-IfA_Smeargle.echo.masks}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.masks:module-contents}}\index{IfA\_Smeargle.echo.masks (module)@\spxentry{IfA\_Smeargle.echo.masks}\spxextra{module}}
This folder just contains all of the masking routines.


\paragraph{Submodules}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo:submodules}}

\subparagraph{IfA\_Smeargle.echo.echo\_functions module}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_functions:module-IfA_Smeargle.echo.echo_functions}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_functions:ifa-smeargle-echo-echo-functions-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_functions::doc}}\index{IfA\_Smeargle.echo.echo\_functions (module)@\spxentry{IfA\_Smeargle.echo.echo\_functions}\spxextra{module}}
These are some functions for the ECHO line that are helpful.
\index{functioned\_mask\_returning() (in module IfA\_Smeargle.echo.echo\_functions)@\spxentry{functioned\_mask\_returning()}\spxextra{in module IfA\_Smeargle.echo.echo\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_functions:IfA_Smeargle.echo.echo_functions.functioned_mask_returning}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.echo\_functions.}}\sphinxbfcode{\sphinxupquote{functioned\_mask\_returning}}}{\emph{pixel\_mask}, \emph{masking\_dictionary}, \emph{filter\_name}, \emph{return\_mask\_only}}{}
This function is a single implementation for returning masks.

Because it is an option for the user to return the mask itself, writing the logic for each
of the masks will get really old.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pixel\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} This is the pixel mask, it is not changed, only where it goes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{masking\_dictionary}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}) \textendash{} This is the mask dictionary provided by the user (or blank by default)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filter\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} This is the name of the filter that is being applied; should be same as the dictionary
entry for this filter.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_mask\_only}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} The decision on if or if not the mask or the dictionary should be returned.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{returning\_object} \textendash{} The object that is to be returned. It is either the mask or the dictionary based on
the boolean value.

\item[{Return type}] \leavevmode
ndarray or dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{numpy\_masked\_array() (in module IfA\_Smeargle.echo.echo\_functions)@\spxentry{numpy\_masked\_array()}\spxextra{in module IfA\_Smeargle.echo.echo\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_functions:IfA_Smeargle.echo.echo_functions.numpy_masked_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.echo\_functions.}}\sphinxbfcode{\sphinxupquote{numpy\_masked\_array}}}{\emph{data\_array}, \emph{synthesized\_mask}, \emph{masking\_dictionary=None}}{}
This function makes a Numpy masked array; a nice built in class for this line.

The Numpy Masked Array class works very well with masking data values in a given array.
It is only natural to use such functionality. This is really a wrapper function for ease of
usage with familiarity of Smeargle’s structures.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data that is to have its mask made.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{synthesized\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The mask that should be applied to the data, it is expected that this is post-synthesis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{masking\_dictionary}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The masking dictionary pre-synthesis. If it is not None, \sphinxcode{\sphinxupquote{synthesized\_mask}} is
completely ignored in favor of this parameter.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{sort\_masking\_dictionary() (in module IfA\_Smeargle.echo.echo\_functions)@\spxentry{sort\_masking\_dictionary()}\spxextra{in module IfA\_Smeargle.echo.echo\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_functions:IfA_Smeargle.echo.echo_functions.sort_masking_dictionary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.echo\_functions.}}\sphinxbfcode{\sphinxupquote{sort\_masking\_dictionary}}}{\emph{mask\_dictionary}}{}
This function just sorts a dictionary by its key.

As the masking dictionary is expected to be in order by its keys, this is sort of needed.
It is not too efficient, and it can be disabled.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{mask\_dictionary}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}) \textendash{} The unsorted mask dictionary.

\item[{Returns}] \leavevmode
\sphinxstylestrong{sorted\_mask\_dictionary} \textendash{} The mask dictionary that is sorted by the ECHO code.

\item[{Return type}] \leavevmode
dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{synthesize\_mask\_dictionary() (in module IfA\_Smeargle.echo.echo\_functions)@\spxentry{synthesize\_mask\_dictionary()}\spxextra{in module IfA\_Smeargle.echo.echo\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_functions:IfA_Smeargle.echo.echo_functions.synthesize_mask_dictionary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.echo\_functions.}}\sphinxbfcode{\sphinxupquote{synthesize\_mask\_dictionary}}}{\emph{masking\_dictionary}}{}
This function takes a masking dictionary and returns it with a final overall mask.

The masking dictionary is made solely because it is helpful to preserve the information as
to which mask applied to which pixel. However, in actual visualization, it is not really
needed.

This function makes a deep copy of the input to ensure it is not damaged. The final
synthesized mask does not have information about each individual mask.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{masking\_dictionary}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}) \textendash{} A masking dictionary made by the procedures of the ECHO line.

\item[{Returns}] \leavevmode
\sphinxstylestrong{synthesized\_mask} \textendash{} A boolean array of the finalized mask properties.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.echo.echo\_main module}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_main:module-IfA_Smeargle.echo.echo_main}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_main:ifa-smeargle-echo-echo-main-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_main::doc}}\index{IfA\_Smeargle.echo.echo\_main (module)@\spxentry{IfA\_Smeargle.echo.echo\_main}\spxextra{module}}\index{echo\_directory\_execution() (in module IfA\_Smeargle.echo.echo\_main)@\spxentry{echo\_directory\_execution()}\spxextra{in module IfA\_Smeargle.echo.echo\_main}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_main:IfA_Smeargle.echo.echo_main.echo_directory_execution}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.echo\_main.}}\sphinxbfcode{\sphinxupquote{echo\_directory\_execution}}}{\emph{data\_directory}, \emph{configuration\_class}, \emph{overwrite=True}, \emph{silent=False}}{}
This function extends the ECHO abilities to entire directories of
using the same configuration file.

The original echo\_execution function only handles a single data array,
computing the mask, and then returning a masked array. This function
extends such capabilities and overwrites the files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The directory to the data files.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{configuration\_class}} ({\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:IfA_Smeargle.yankee.yankee_main.SmeargleConfig}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{SmeargleConfig}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{EchoConfig class}}) \textendash{} The configuration class (and by extension, filters) that are to be
used for all files.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{overwrite}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} An option to decide if the files should be overwritten or renamed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{silent}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Turn off all warnings and information sent by this function and
functions below it.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{echo\_execution() (in module IfA\_Smeargle.echo.echo\_main)@\spxentry{echo\_execution()}\spxextra{in module IfA\_Smeargle.echo.echo\_main}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.echo.echo_main:IfA_Smeargle.echo.echo_main.echo_execution}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.echo.echo\_main.}}\sphinxbfcode{\sphinxupquote{echo\_execution}}}{\emph{data\_array}, \emph{configuration\_class}, \emph{silent=False}}{}
This script pragmatically uses a configuration class to determine
which filters to use.

This function goes through all possible filters, applying those that the
user specified in their configuration file. It only applies those which
are flagged to run where there is also some configuration. It handles
cases where this is not true accordingly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The data array that is to processed and filtered accordingly. A fits
file is also acceptable.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{configuration\_class}} ({\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:IfA_Smeargle.yankee.yankee_main.SmeargleConfig}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{SmeargleConfig}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{EchoConfig class}}) \textendash{} The configuration class that will be used to provide instruction
to the ECHO filters.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{silent}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If true, then no warnings or informational messages will be displayed.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{masked\_array} (\sphinxstyleemphasis{Masked Array}) \textendash{} The data containing the masked values from the mask provided in the
configuration parameters.

\item {} 
\sphinxstylestrong{masking\_dict} (\sphinxstyleemphasis{dictionary}) \textendash{} The dictionary of all of the masks applied.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{python_docstrings/IfA_Smeargle.echo:module-IfA_Smeargle.echo}}\label{\detokenize{python_docstrings/IfA_Smeargle.echo:module-contents}}\index{IfA\_Smeargle.echo (module)@\spxentry{IfA\_Smeargle.echo}\spxextra{module}}

\subsubsection{IfA\_Smeargle.meta package}
\label{\detokenize{python_docstrings/IfA_Smeargle.meta:ifa-smeargle-meta-package}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta::doc}}

\paragraph{Submodules}
\label{\detokenize{python_docstrings/IfA_Smeargle.meta:submodules}}

\subparagraph{IfA\_Smeargle.meta.configuration module}
\label{\detokenize{python_docstrings/IfA_Smeargle.meta.configuration:module-IfA_Smeargle.meta.configuration}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.configuration:ifa-smeargle-meta-configuration-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.configuration::doc}}\index{IfA\_Smeargle.meta.configuration (module)@\spxentry{IfA\_Smeargle.meta.configuration}\spxextra{module}}
These functions just provide a nice and easy place to put functions whose
purpose is to allow for the proper reading of different possible arrangements
of the configuration parameters.
\index{extract\_proper\_configuration\_class() (in module IfA\_Smeargle.meta.configuration)@\spxentry{extract\_proper\_configuration\_class()}\spxextra{in module IfA\_Smeargle.meta.configuration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.configuration:IfA_Smeargle.meta.configuration.extract_proper_configuration_class}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.configuration.}}\sphinxbfcode{\sphinxupquote{extract\_proper\_configuration\_class}}}{\emph{configuration\_class}, \emph{desired\_class}, \emph{deep\_copy=False}}{}
This function extracts the proper configuration class from a
collection of configuration classes.

The whole point of this function is to retain the flexibility and ease
of using differing configuration classes and the structure of the
configuration classes themselves.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{configuration\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any BaseConfig based class}}) \textendash{} The main configuration class that should contain the desired class.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{desired\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any BaseConfig based class execpt for BaseConfig}}) \textendash{} The desired class.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{deep\_copy}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If a deep copy of the class is desired, then set to True.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{extracted\_class} \textendash{} A copy of the desired configuration class.

\item[{Return type}] \leavevmode
Any BaseConfig based class (same class as desired class)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.meta.errors module}
\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:module-IfA_Smeargle.meta.errors}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:ifa-smeargle-meta-errors-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors::doc}}\index{IfA\_Smeargle.meta.errors (module)@\spxentry{IfA\_Smeargle.meta.errors}\spxextra{module}}
Defining custom errors because Python does not have all of the needed error
categories.
\index{BrokenLogicError@\spxentry{BrokenLogicError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.BrokenLogicError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{BrokenLogicError}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Exception}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Exception}}}}}

This error is encountered when the program enters in a place it should
not be able to. Incorporated mostly for safety; usually not the fault of
the user.

\end{fulllineitems}

\index{ConfigurationError@\spxentry{ConfigurationError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.ConfigurationError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{ConfigurationError}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Exception}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Exception}}}}}

This error is normally encountered when there are problems with
configuration processing (usually because the configuration class is
incorrect).

\end{fulllineitems}

\index{ConfigurationWarning@\spxentry{ConfigurationWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.ConfigurationWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{ConfigurationWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used when there are issues with the configuration class
and that data is missing. However, the missing data does not warrant an
exception.

\end{fulllineitems}

\index{DataError@\spxentry{DataError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.DataError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{DataError}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Exception}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Exception}}}}}

This error is used when there is an issue with the fundamental data that
this program or module cannot fix. The user should be able to figure out
what is the problem.

\end{fulllineitems}

\index{DataWarning@\spxentry{DataWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.DataWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{DataWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used when there is an issue with the fundamental data that
this program or module cannot fix but can still work around. The user
should be able to figure out what is the problem.

\end{fulllineitems}

\index{DepreciationWarning@\spxentry{DepreciationWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.DepreciationWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{DepreciationWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used when there are some functions that are used but
have since been replaced with better functions, or where the previous
function is not very stable or integrated with the rest of the functions.

\end{fulllineitems}

\index{ExportingError@\spxentry{ExportingError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.ExportingError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{ExportingError}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Exception}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Exception}}}}}

This error is used when the program attempts to export data in some way,
but is unable to. Named ExportingError to keep with ImportingError.

\end{fulllineitems}

\index{IllogicalProsedureError@\spxentry{IllogicalProsedureError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.IllogicalProsedureError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{IllogicalProsedureError}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Exception}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Exception}}}}}

This error is thrown when the program would attempt something that does
not make scene. This is usually due to issues with configuration errors.

\end{fulllineitems}

\index{ImportingError@\spxentry{ImportingError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.ImportingError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{ImportingError}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Exception}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Exception}}}}}

This error is used when reading configuration files, or other data files
is not going as it should. Named ImportingError to avoid conflicts with
ImportError.

\end{fulllineitems}

\index{ImportingWarning@\spxentry{ImportingWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.ImportingWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{ImportingWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used when there are issues loading a file, but it can
be handled using some assumptions.

\end{fulllineitems}

\index{ImprecisionError@\spxentry{ImprecisionError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.ImprecisionError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{ImprecisionError}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Exception}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Exception}}}}}

This error is used when there are critical issues with numerical
precision because of the volume of data or the very low/high numbers
involved. It is also just used when data may be chaotic.

\end{fulllineitems}

\index{ImprecisionWarning@\spxentry{ImprecisionWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.ImprecisionWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{ImprecisionWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used when there may be issues with numerical precision
because of the volume of data or the very low/high numbers involved.

\end{fulllineitems}

\index{IncompleteError@\spxentry{IncompleteError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.IncompleteError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{IncompleteError}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_BaseException}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_BaseException}}}}}

This used when the code is trying to use a function that is incomplete or
not usable.

\end{fulllineitems}

\index{InputError@\spxentry{InputError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.InputError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{InputError}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Exception}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Exception}}}}}

This error is used when the user does not input a proper or logical entry.

\end{fulllineitems}

\index{InputWarning@\spxentry{InputWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.InputWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{InputWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used when the user inputs something that is questionable,
but not wrong.

\end{fulllineitems}

\index{MaskingError@\spxentry{MaskingError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.MaskingError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{MaskingError}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Exception}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Exception}}}}}

This error is used when a mask cannot be applied or where there are
fatal issues with calculating the mask.

\end{fulllineitems}

\index{MaskingWarning@\spxentry{MaskingWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.MaskingWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{MaskingWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used when any masking routine (especially in the ECHO
line) fails to mask any pixels. It is not a bad thing, but it can be
helpful to know.

\end{fulllineitems}

\index{MemoryWarning@\spxentry{MemoryWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.MemoryWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{MemoryWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used to warn the user that the procedures that follow
would require a lot of memory RAM. If instead it would produce a large
file(s), StorageWarning should be used.

\end{fulllineitems}

\index{ModelingError@\spxentry{ModelingError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.ModelingError}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{ModelingError}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Exception}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Exception}}}}}

This error is used when there are issues with applying or fitting models
to a particular set of data. May be used hand-in-hand with DataError.

\end{fulllineitems}

\index{OutputWarning@\spxentry{OutputWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.OutputWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{OutputWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used to warn the user about outputs and some things that
may be helpful to know about them. Such outputs are generally writing
file outputs.

\end{fulllineitems}

\index{OverwriteWarning@\spxentry{OverwriteWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.OverwriteWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{OverwriteWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used to warn the user that a file has been overwritten,
most likely because of conflicting file names.

\end{fulllineitems}

\index{ReductionWarning@\spxentry{ReductionWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.ReductionWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{ReductionWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used when normally unusual parameters are used for data
reduction. The user is trusted in their procedures.

\end{fulllineitems}

\index{Smeargle\_BaseException@\spxentry{Smeargle\_BaseException}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_BaseException}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{Smeargle\_BaseException}}}
Bases: \sphinxcode{\sphinxupquote{BaseException}}

\end{fulllineitems}

\index{Smeargle\_Exception@\spxentry{Smeargle\_Exception}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Exception}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{Smeargle\_Exception}}}
Bases: \sphinxcode{\sphinxupquote{Exception}}

\end{fulllineitems}

\index{Smeargle\_Warning@\spxentry{Smeargle\_Warning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{Smeargle\_Warning}}}
Bases: \sphinxcode{\sphinxupquote{UserWarning}}

\end{fulllineitems}

\index{StorageWarning@\spxentry{StorageWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.StorageWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{StorageWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used when the large file(s) would be written to the hard
drive. If instead a lot of RAM would be used, it is better to use
MemoryWarning.

\end{fulllineitems}

\index{TerminalError@\spxentry{TerminalError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.TerminalError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{TerminalError}}}{\emph{message=None}}{}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_BaseException}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_BaseException}}}}}

Something has gone terribly wrong. It is best to contact Sparrow.

\end{fulllineitems}

\index{TimeWarning@\spxentry{TimeWarning}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.TimeWarning}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{TimeWarning}}}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.Smeargle_Warning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.Smeargle\_Warning}}}}}

This warning is used when any method called may take a long time to
compute or execute. This allows the user to stop and change if desired.

\end{fulllineitems}

\index{smeargle\_absolute\_silence() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_absolute\_silence()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_absolute_silence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_absolute\_silence}}}{}{}
This context manager silences any and all messages, it basically
it is wrapper around all other general Smeargle context managers (even
if there is some overlap).

\end{fulllineitems}

\index{smeargle\_debug\_block() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_debug\_block()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_debug_block}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_debug\_block}}}{}{}
This is a wrapper function for encasing debugging code.

The execution of code within a debug block is used to contain easily
printed debug information. Debug messages should use the debug function
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_debug_message}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{smeargle\_debug\_message()}}}}}

\end{fulllineitems}

\index{smeargle\_debug\_message() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_debug\_message()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_debug_message}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_debug\_message}}}{\emph{message}}{}
This is a wrapper function for the printing of debug messages.

Given the nature of debug messages, it should be clear that it is a debug
message, and should also have the proper silencing capabilities.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{message}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The message that is to be sent as the debug message.

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{smeargle\_disable\_debug() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_disable\_debug()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_disable_debug}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_disable\_debug}}}{}{}
This context manager turns all debug messages off for the duration of
the context. Given that debug messages are generally off in the first
place, usage may be rare.

\end{fulllineitems}

\index{smeargle\_enable\_debug() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_enable\_debug()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_enable_debug}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_enable\_debug}}}{}{}
This context manager turns all debug messages on for the duration of
the context.

\end{fulllineitems}

\index{smeargle\_info() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_info()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_info}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_info}}}{\emph{message}}{}
This is a wrapper function to print helpful information.

Printing information as the function(s) go on is very helpful. However,
using the normal print function doesn’t allow for some level of
customization and ease of handling. Hence, function for uniformity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{message}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The informational message that is to be printed.

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{smeargle\_silence\_all\_warnings() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_silence\_all\_warnings()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_silence_all_warnings}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_silence\_all\_warnings}}}{}{}
This context manager silences all warnings. Warnings should not be
printed.

\end{fulllineitems}

\index{smeargle\_silence\_ifas\_warnings() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_silence\_ifas\_warnings()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_silence_ifas_warnings}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_silence\_ifas\_warnings}}}{}{}
This context manager silences all Smeargle based warnings, all other
warnings are still valid.

\end{fulllineitems}

\index{smeargle\_silence\_info\_message() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_silence\_info\_message()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_silence_info_message}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_silence\_info\_message}}}{}{}
This context manager silences all informational messages that may
be printed.

\end{fulllineitems}

\index{smeargle\_silence\_nonifas\_warnings() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_silence\_nonifas\_warnings()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_silence_nonifas_warnings}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_silence\_nonifas\_warnings}}}{}{}
This context manager silences all non-Smeargle based warnings, all
other warnings are still valid.

\end{fulllineitems}

\index{smeargle\_silence\_specific\_warnings() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_silence\_specific\_warnings()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_silence_specific_warnings}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_silence\_specific\_warnings}}}{\emph{silenced\_warning\_type}}{}
This context manager silences all warnings of a given type. Depending
on what was inputed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{silenced\_warning\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{WarningType}}) \textendash{} The warning that should be silenced.

\end{description}\end{quote}

\end{fulllineitems}

\index{smeargle\_warning() (in module IfA\_Smeargle.meta.errors)@\spxentry{smeargle\_warning()}\spxextra{in module IfA\_Smeargle.meta.errors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.errors:IfA_Smeargle.meta.errors.smeargle_warning}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.errors.}}\sphinxbfcode{\sphinxupquote{smeargle\_warning}}}{\emph{type}, \emph{message}}{}
Just a wrapper function around the warning’s warn command.

This wrapper was really only for the logical flow of Sparrow.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{type}} (\sphinxstyleliteralemphasis{\sphinxupquote{Warnings Class}}) \textendash{} The warning class type.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{message}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The message that the warning is to give to the user.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.meta.fits\_and\_arrays module}
\label{\detokenize{python_docstrings/IfA_Smeargle.meta.fits_and_arrays:module-IfA_Smeargle.meta.fits_and_arrays}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.fits_and_arrays:ifa-smeargle-meta-fits-and-arrays-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.fits_and_arrays::doc}}\index{IfA\_Smeargle.meta.fits\_and\_arrays (module)@\spxentry{IfA\_Smeargle.meta.fits\_and\_arrays}\spxextra{module}}
This file contains functions dealing with the loading and handling of fits files and their
associated header and data arrays.
\index{smeargle\_extract\_subarray() (in module IfA\_Smeargle.meta.fits\_and\_arrays)@\spxentry{smeargle\_extract\_subarray()}\spxextra{in module IfA\_Smeargle.meta.fits\_and\_arrays}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.fits_and_arrays:IfA_Smeargle.meta.fits_and_arrays.smeargle_extract_subarray}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.fits\_and\_arrays.}}\sphinxbfcode{\sphinxupquote{smeargle\_extract\_subarray}}}{\emph{primary\_array}, \emph{x\_bounds}, \emph{y\_bounds}}{}
A function to extract a smaller array copy from a larger array.

Sub-arrays are rather important in the analysis of specific arrays.
This function extracts a sub-array from a given primary array specified
by the x\_bounds and y\_bounds.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{primary\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} This is the data array that is desired to be sliced.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_bounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{list-like}}) \textendash{} The bounds of the x-axis of a given array.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_bounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{list-like}}) \textendash{} The bounds of the y-axis of a given array.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{sub\_array} \textendash{} An array containing only data within the xy-bounds provided.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{smeargle\_masked\_array\_min\_max() (in module IfA\_Smeargle.meta.fits\_and\_arrays)@\spxentry{smeargle\_masked\_array\_min\_max()}\spxextra{in module IfA\_Smeargle.meta.fits\_and\_arrays}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.fits_and_arrays:IfA_Smeargle.meta.fits_and_arrays.smeargle_masked_array_min_max}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.fits\_and\_arrays.}}\sphinxbfcode{\sphinxupquote{smeargle\_masked\_array\_min\_max}}}{\emph{masked\_array}}{}
This function returns a masked array’s minimum and maximum value.

This function determines the minimum and maximum of a masked arrays
between valid, unmasked, values only. Masked values are not considered
for min-max evaluation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{masked\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{masked ndarray}}) \textendash{} The array that has a mask, and is also the one that will have a
min max calculated.

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{masked\_min} (\sphinxstyleemphasis{float}) \textendash{} The value of the minimum of the masked array ignoring masking.

\item {} 
\sphinxstylestrong{masked\_max} (\sphinxstyleemphasis{float}) \textendash{} The value of the maximum of the masked array ignoring masking.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{smeargle\_open\_fits\_file() (in module IfA\_Smeargle.meta.fits\_and\_arrays)@\spxentry{smeargle\_open\_fits\_file()}\spxextra{in module IfA\_Smeargle.meta.fits\_and\_arrays}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.fits_and_arrays:IfA_Smeargle.meta.fits_and_arrays.smeargle_open_fits_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.fits\_and\_arrays.}}\sphinxbfcode{\sphinxupquote{smeargle\_open\_fits\_file}}}{\emph{file\_name}, \emph{extension=0}, \emph{silent=False}}{}
A function to ensure proper loading/reading of fits files.

This function, as its name, opens a fits file. It returns the Astropy HDU
file. This function is mostly done to ensure that files are properly
closed. It also extracts the needed data and header information from the
file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} This is the path of the file to be read, either relative or absolute.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{extension}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The desired extension of the fits file. Defaults to primary structure.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{silent}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Turn off all warnings and information sent by this function and
functions below it.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{hdu\_file} (\sphinxstyleemphasis{HDULists}) \textendash{} The Astropy object representing the fits file.

\item {} 
\sphinxstylestrong{hdu\_header} (\sphinxstyleemphasis{Header}) \textendash{} The Astropy header object representing the headers of the given file.

\item {} 
\sphinxstylestrong{hdu\_data} (\sphinxstyleemphasis{ndarray}) \textendash{} The Numpy representation of a fits file data.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{smeargle\_write\_fits\_file() (in module IfA\_Smeargle.meta.fits\_and\_arrays)@\spxentry{smeargle\_write\_fits\_file()}\spxextra{in module IfA\_Smeargle.meta.fits\_and\_arrays}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.fits_and_arrays:IfA_Smeargle.meta.fits_and_arrays.smeargle_write_fits_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.fits\_and\_arrays.}}\sphinxbfcode{\sphinxupquote{smeargle\_write\_fits\_file}}}{\emph{file\_name}, \emph{hdu\_header}, \emph{hdu\_data}, \emph{hdu\_object=None}, \emph{save\_file=True}, \emph{overwrite=True}, \emph{silent=False}}{}
A function to ensure proper writing of fits files.

This function writes fits files given the data and header file. The
file name should be a complete path and must also include the file name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} This is the path of the file to be written, either relative or
absolute.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hdu\_header}} (\sphinxstyleliteralemphasis{\sphinxupquote{Header}}) \textendash{} The Astropy header object representing the headers of the given file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hdu\_data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The Numpy representation of a fits file data.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hdu\_object}} (\sphinxstyleliteralemphasis{\sphinxupquote{Astropy HDUList}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} An astropy HDUList object, if provided, this object takes priority
to be written, the rest are ignored.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If \sphinxcode{\sphinxupquote{True}}, then the fits file will be written to file, else, just
the instance will be returned.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{overwrite}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If \sphinxcode{\sphinxupquote{True}}, if there exists a file of the same name, overwrite.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{silent}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Turn off all warnings and information sent by this function and
functions below it.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{hdul\_file} \textendash{} The file object that was written to disk. If \sphinxcode{\sphinxupquote{hdu\_object}} was
provided, it is returned untouched.

\item[{Return type}] \leavevmode
Astropy HDUList

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.meta.meta\_main module}
\label{\detokenize{python_docstrings/IfA_Smeargle.meta.meta_main:module-IfA_Smeargle.meta.meta_main}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.meta_main:ifa-smeargle-meta-meta-main-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.meta_main::doc}}\index{IfA\_Smeargle.meta.meta\_main (module)@\spxentry{IfA\_Smeargle.meta.meta\_main}\spxextra{module}}
The purpose of this module is to implement shortcuts that are used throughout the Smeargle
lines and that contain fixes to problems the user may find helpful that it is already
preprogrammed.

CAUTION: THIS IS NOT A SMEARGLE LINE. THESE ARE METAFUNCTIONS/CLASSES


\subparagraph{IfA\_Smeargle.meta.modeling\_and\_fitting module}
\label{\detokenize{python_docstrings/IfA_Smeargle.meta.modeling_and_fitting:module-IfA_Smeargle.meta.modeling_and_fitting}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.modeling_and_fitting:ifa-smeargle-meta-modeling-and-fitting-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.modeling_and_fitting::doc}}\index{IfA\_Smeargle.meta.modeling\_and\_fitting (module)@\spxentry{IfA\_Smeargle.meta.modeling\_and\_fitting}\spxextra{module}}\index{smeargle\_fit\_gaussian\_function() (in module IfA\_Smeargle.meta.modeling\_and\_fitting)@\spxentry{smeargle\_fit\_gaussian\_function()}\spxextra{in module IfA\_Smeargle.meta.modeling\_and\_fitting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.modeling_and_fitting:IfA_Smeargle.meta.modeling_and_fitting.smeargle_fit_gaussian_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.modeling\_and\_fitting.}}\sphinxbfcode{\sphinxupquote{smeargle\_fit\_gaussian\_function}}}{\emph{x\_data}, \emph{y\_data}, \emph{inital\_guesses}}{}
This function fits a Gaussian function to a specific set of data.

Gaussian fitting is hard, this function exists as a port so that
all fitting functions use the same algorithm and said algorithm is easy
to change.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The X data that the Gaussian will be fit over.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The Y data that the Gaussian will be fit over.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inital\_guesses}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}) \textendash{} Initial guesses for the Gaussian fitting function.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{gaussian\_function} (\sphinxstyleemphasis{function}) \textendash{} A callable function that when provided an X value, it will return
the value of the function.

\item {} 
\sphinxstylestrong{gaussian\_parameters} (\sphinxstyleemphasis{dictionary}) \textendash{} A compiled dictionary of all of the parameters of the Gaussian fit.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{smeargle\_fit\_histogram\_gaussian\_function() (in module IfA\_Smeargle.meta.modeling\_and\_fitting)@\spxentry{smeargle\_fit\_histogram\_gaussian\_function()}\spxextra{in module IfA\_Smeargle.meta.modeling\_and\_fitting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.modeling_and_fitting:IfA_Smeargle.meta.modeling_and_fitting.smeargle_fit_histogram_gaussian_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.modeling\_and\_fitting.}}\sphinxbfcode{\sphinxupquote{smeargle\_fit\_histogram\_gaussian\_function}}}{\emph{data\_array}, \emph{bin\_width=10}}{}
This function fits a Gaussian function to a specific set of data.

Gaussian fitting is hard, this function exists as a port so that
all fitting functions use the same algorithm and said algorithm is easy
to change. This applies it to the histogram of the data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data that the histogram Gaussian function is fitting.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bin\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The width of the bins to use for the histogram fitting function.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{gaussian\_function} (\sphinxstyleemphasis{function}) \textendash{} A callable function that when provided an X value, it will return
the value of the function.

\item {} 
\sphinxstylestrong{gaussian\_parameters} (\sphinxstyleemphasis{dictionary}) \textendash{} A compiled dictionary of all of the parameters of the Gaussian fit.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.meta.plotting module}
\label{\detokenize{python_docstrings/IfA_Smeargle.meta.plotting:module-IfA_Smeargle.meta.plotting}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.plotting:ifa-smeargle-meta-plotting-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta.plotting::doc}}\index{IfA\_Smeargle.meta.plotting (module)@\spxentry{IfA\_Smeargle.meta.plotting}\spxextra{module}}
This module just adds some shortcut calling functions to functionality of plotting functions
and related methods.

Although the implementation of the entire functionality module is supposed to be untouched,
it is still suggested that these functions be used over custom approaches when applicable.
\index{smeargle\_save\_figure\_file() (in module IfA\_Smeargle.meta.plotting)@\spxentry{smeargle\_save\_figure\_file()}\spxextra{in module IfA\_Smeargle.meta.plotting}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.meta.plotting:IfA_Smeargle.meta.plotting.smeargle_save_figure_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.meta.plotting.}}\sphinxbfcode{\sphinxupquote{smeargle\_save\_figure\_file}}}{\emph{figure}, \emph{file\_name}, \emph{title=None}, \emph{close\_figure=True}}{}
This function just saves a figure to a file to a name provided.

Because of some oddities with Matplotlib, saving a file within a function
and exiting said function (or overwriting in a loop its variable) with a
new figure causes two figures to be saved in parallel. This is very
memory intensive, so closing a saved figure is ideal.

This function does it so the user or Smeargle lines do not need to care
about it.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{figure}} (\sphinxstyleliteralemphasis{\sphinxupquote{Matplotlib Figure}}) \textendash{} This is the figure to be saved to a file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} This is the file string name for the figure to be saved. It should
already have the appropriate extension. If not, it defaults to pdf.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} This is the title for the figure plot. Although it can be added from
here, it is not advised.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{close\_figure}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} This specifies if the figure should be closed. Given that this
function is built for that, this should not be changed.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{return\_none} \textendash{} Nothing

\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
The file type checking logic is not the smartest implementation.
\end{sphinxadmonition}

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{python_docstrings/IfA_Smeargle.meta:module-IfA_Smeargle.meta}}\label{\detokenize{python_docstrings/IfA_Smeargle.meta:module-contents}}\index{IfA\_Smeargle.meta (module)@\spxentry{IfA\_Smeargle.meta}\spxextra{module}}

\subsubsection{IfA\_Smeargle.oscar package}
\label{\detokenize{python_docstrings/IfA_Smeargle.oscar:ifa-smeargle-oscar-package}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar::doc}}

\paragraph{Submodules}
\label{\detokenize{python_docstrings/IfA_Smeargle.oscar:submodules}}

\subparagraph{IfA\_Smeargle.oscar.heatmaps module}
\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.heatmaps:module-IfA_Smeargle.oscar.heatmaps}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.heatmaps:ifa-smeargle-oscar-heatmaps-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.heatmaps::doc}}\index{IfA\_Smeargle.oscar.heatmaps (module)@\spxentry{IfA\_Smeargle.oscar.heatmaps}\spxextra{module}}
This file contains all of the different methods that a heatmap can be plotted.
\index{plot\_array\_heatmap\_image() (in module IfA\_Smeargle.oscar.heatmaps)@\spxentry{plot\_array\_heatmap\_image()}\spxextra{in module IfA\_Smeargle.oscar.heatmaps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.heatmaps:IfA_Smeargle.oscar.heatmaps.plot_array_heatmap_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.oscar.heatmaps.}}\sphinxbfcode{\sphinxupquote{plot\_array\_heatmap\_image}}}{\emph{data\_array}, \emph{figure\_axes=None}, \emph{plot=True}, \emph{heatmap\_plot\_parameters=\{'interpolation': 'nearest'\}}, \emph{colorbar\_plot\_paramters=\{'orientation': 'vertical'\}}}{}
A function to create a heatmap image of the data array provided.

This function replicates the image plotting functionality of Tino Well’s
program. (Found here: \sphinxurl{https://github.com/tinowells/ifa}). More
specifically, the plot assigns a color according to the value a pixel
has, and plots it corresponding to its location in the provided data
array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} This is the provided array that is to be plotted. Dimensions matter!
May also be a fits file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{figure\_axes}} (\sphinxstyleliteralemphasis{\sphinxupquote{Matplotlib Axes}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} This is a predefined axes variable that the user may desire to have
the heatmap plot to. This defaults to either making new ones, or
using the currently defined axes. Note: This is not deep-copied!

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} A flag to check if this plotting function should be run. A component
in the mutli-plot functions.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{heatmap\_plot\_parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary \textless{}config\textgreater{}}}) \textendash{} These are options the user may use to pass customization parameters
into the heatmap plot functionality.
See \sphinxcode{\sphinxupquote{imshow()}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{colorbar\_plot\_paramters}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary \textless{}config\textgreater{}}}) \textendash{} These are options the user may use to pass customization parameters
into the colorbar class functionality.
See \sphinxcode{\sphinxupquote{colorbar()}}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{heatmap\_plot\_axes} \textendash{} This is the heatmap plot made on the (provided, borrowed, or
generated) plotting axes.

\item[{Return type}] \leavevmode
Matplotlib Axes

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.oscar.histograms module}
\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.histograms:module-IfA_Smeargle.oscar.histograms}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.histograms:ifa-smeargle-oscar-histograms-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.histograms::doc}}\index{IfA\_Smeargle.oscar.histograms (module)@\spxentry{IfA\_Smeargle.oscar.histograms}\spxextra{module}}
This contains all of the histogram plotting methods.
\index{plot\_array\_histogram() (in module IfA\_Smeargle.oscar.histograms)@\spxentry{plot\_array\_histogram()}\spxextra{in module IfA\_Smeargle.oscar.histograms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.histograms:IfA_Smeargle.oscar.histograms.plot_array_histogram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.oscar.histograms.}}\sphinxbfcode{\sphinxupquote{plot\_array\_histogram}}}{\emph{data\_array}, \emph{figure\_axes=None}, \emph{fit\_gaussian=True}, \emph{bin\_width=None}, \emph{plot=True}, \emph{histogram\_plot\_paramters=\{\}}}{}
A function to create and plot histogram plots for better analysis of
a given array.

This function replicates the histogram plotting functionality of Tino
Well’s program. (Found here: \sphinxurl{https://github.com/tinowells/ifa}). More
specifically, it attempts to plot histograms of pixel data; then, the
program attempts to fit a Gaussian function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} This is the data array that is expected to be analyzed and have
histograms made. May also be a fits file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{figure\_axes}} (\sphinxstyleliteralemphasis{\sphinxupquote{Matplotlib Axes}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} This is a predefined axes variable that the user may desire to have
the histogram plot to. This defaults to either making new ones, or
using the currently defined axes. This is not deep-copied!

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fit\_gaussian}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} This parameter regulates if the function should replicate the
Gaussian function fitting.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bin\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Matplotlib is not nice with bin widths, if it is an integer, widths
are applied instead.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} A flag to check if this plotting function should be run. A component
in the mutli-plot functions. Defaults to true.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{histogram\_plot\_parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary \textless{}config\textgreater{}}}) \textendash{} These are options the user may use to pass customization parameters
into the histogram plot functionality.
See \sphinxcode{\sphinxupquote{hist()}}.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{histogram\_plot\_axes} (\sphinxstyleemphasis{Matplotlib Axes}) \textendash{} This is the histogram plot made on the (provided, borrowed, or
generated) plotting axes.

\item {} 
\sphinxstylestrong{gaussian\_fit\_atributes} (\sphinxstyleemphasis{dictionary}) \textendash{} This is a dictionary of the mean, stddev, amplitude, and maximum of
the computed/fit Gaussian model.

\end{itemize}


\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
If the \sphinxcode{\sphinxupquote{histogram\_plot\_parameters}} specifies that the histogram plot
should be logarithmic, the Gaussian function will be disabled because of
some incompatibilities.
\end{sphinxadmonition}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.oscar.multi\_figure module}
\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.multi_figure:module-IfA_Smeargle.oscar.multi_figure}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.multi_figure:ifa-smeargle-oscar-multi-figure-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.multi_figure::doc}}\index{IfA\_Smeargle.oscar.multi\_figure (module)@\spxentry{IfA\_Smeargle.oscar.multi\_figure}\spxextra{module}}
This is used when multiple figures are to be plotted in one file or system.
These instead take configuration classes.
\index{plot\_single\_heatmap\_and\_histogram() (in module IfA\_Smeargle.oscar.multi\_figure)@\spxentry{plot\_single\_heatmap\_and\_histogram()}\spxextra{in module IfA\_Smeargle.oscar.multi\_figure}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.multi_figure:IfA_Smeargle.oscar.multi_figure.plot_single_heatmap_and_histogram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.oscar.multi\_figure.}}\sphinxbfcode{\sphinxupquote{plot\_single\_heatmap\_and\_histogram}}}{\emph{data\_array}, \emph{configuration\_class=None}, \emph{figure\_subplot\_parameters=\{'dpi': 100}, \emph{'figsize': (9}, \emph{3.5)\}}}{}
This extracts data from a single data array, plotting a histogram
and heatmap.

This function attempts to plot both a histogram and a heatmap
side-by-side given a data array. Although all of the customizable
parameters may be sent via the dictionary, this is not the suggested
method if extreme customization of the figure is needed. However, if the
current arrangement is fine, then so too should this function be.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} This is the data array that is expected to be analyzed and have
histograms made. It can also be a fits file if desired.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{configuration\_class}} ({\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:IfA_Smeargle.yankee.yankee_main.SmeargleConfig}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{SmeargleConfig}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{OscarConfig class.}}) \textendash{} The configuration options for the plotting functionality.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{figure\_subplot\_parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary \textless{}config\textgreater{}}}) \textendash{} These are parameters that are passed straight into the subplot
routine to make the figure.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{final\_figure} \textendash{} This is the final figure made of the heatmap and the histogram.

\item[{Return type}] \leavevmode
Matplotlib Figure

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.oscar.oscar\_functions module}
\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.oscar_functions:module-IfA_Smeargle.oscar.oscar_functions}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.oscar_functions:ifa-smeargle-oscar-oscar-functions-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.oscar_functions::doc}}\index{IfA\_Smeargle.oscar.oscar\_functions (module)@\spxentry{IfA\_Smeargle.oscar.oscar\_functions}\spxextra{module}}\index{oscar\_bin\_width() (in module IfA\_Smeargle.oscar.oscar\_functions)@\spxentry{oscar\_bin\_width()}\spxextra{in module IfA\_Smeargle.oscar.oscar\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.oscar_functions:IfA_Smeargle.oscar.oscar_functions.oscar_bin_width}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.oscar.oscar\_functions.}}\sphinxbfcode{\sphinxupquote{oscar\_bin\_width}}}{\emph{data\_array}, \emph{bin\_width}, \emph{local\_minimum=None}, \emph{local\_maximum=None}}{}
Matplotlib does not support having input bin withs; this returns a
valid form.

This function just generates a valid bin value list provided a given
bin widths. If the \sphinxcode{\sphinxupquote{local\_maximum}} or \sphinxcode{\sphinxupquote{local\_minimum value}} is not
provided, then the absolute maximum and minimum of the provided array is
used.

If mod{[}(max - min), bin\_width{]} != 0, the last/highest bin is
disenfranchised. This function can adapt to masked arrays.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} The data to which the bins will be calculated from; ignored if the two
local maximum and minimum parameters are provided.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bin\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The width of the bins.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{local\_minimum}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} A predefined minimum that the calculating function should use.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{local\_maximum}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} A predefined maximum that the calculating function should use.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{bin\_list\_values} \textendash{} A list of values that can be fed into matplotlib to emulate binning by
a value width.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{oscar\_convert\_data\_inputs() (in module IfA\_Smeargle.oscar.oscar\_functions)@\spxentry{oscar\_convert\_data\_inputs()}\spxextra{in module IfA\_Smeargle.oscar.oscar\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.oscar_functions:IfA_Smeargle.oscar.oscar_functions.oscar_convert_data_inputs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.oscar.oscar\_functions.}}\sphinxbfcode{\sphinxupquote{oscar\_convert\_data\_inputs}}}{\emph{data}, \emph{desired\_form=\textless{}class 'numpy.ma.core.MaskedArray'\textgreater{}}}{}
Converts between the many different types of inputs that are accepted.

The following forms of data are currently accepted:
- Numpy Array
- Numpy Masked Array
- .fits files (a string)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any of the aforementioned types.}}) \textendash{} The input data that is to be converted.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{desired\_form}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any of the aforementioned types.}}) \textendash{} The type that the output would be in.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{converted\_data} \textendash{} The data after conversion in its desired form.

\item[{Return type}] \leavevmode
Numpy Masked Array

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.oscar.oscar\_main module}
\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.oscar_main:module-IfA_Smeargle.oscar.oscar_main}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.oscar_main:ifa-smeargle-oscar-oscar-main-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar.oscar_main::doc}}\index{IfA\_Smeargle.oscar.oscar\_main (module)@\spxentry{IfA\_Smeargle.oscar.oscar\_main}\spxextra{module}}
The main objective of the OSCAR line is to create plots and histograms displaying and
categorizing different elements of arrays and specifically defined sub-arrays.

Most of the procedures derived from this module element is derived from
\sphinxurl{https://github.com/tinowells/ifa}, as an extension and generalization of said project.


\paragraph{Module contents}
\label{\detokenize{python_docstrings/IfA_Smeargle.oscar:module-IfA_Smeargle.oscar}}\label{\detokenize{python_docstrings/IfA_Smeargle.oscar:module-contents}}\index{IfA\_Smeargle.oscar (module)@\spxentry{IfA\_Smeargle.oscar}\spxextra{module}}

\subsubsection{IfA\_Smeargle.yankee package}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee:ifa-smeargle-yankee-package}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee::doc}}

\paragraph{Subpackages}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee:subpackages}}

\subparagraph{IfA\_Smeargle.yankee.configuration\_classes package}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes:ifa-smeargle-yankee-configuration-classes-package}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes::doc}}

\subparagraph{Submodules}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes:submodules}}

\subparagraph{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file module}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:module-IfA_Smeargle.yankee.configuration_classes.BaseConfig_file}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:ifa-smeargle-yankee-configuration-classes-baseconfig-file-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file::doc}}\index{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file (module)@\spxentry{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file}\spxextra{module}}\index{BaseConfig (class in IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file)@\spxentry{BaseConfig}\spxextra{class in IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.}}\sphinxbfcode{\sphinxupquote{BaseConfig}}}
Bases: \sphinxcode{\sphinxupquote{object}}

The base configuration class for the Smeargle Yankee configuration
line.

This is the parent class of the configuration classes. This is mostly for
attributes or functions which all classes should have.
\index{\_\_str\_\_() (IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig method)@\spxentry{\_\_str\_\_()}\spxextra{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig.__str__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_str\_\_}}}{}{}
The print visualization of the configuration classes.

This is for a good amount of printing and visualization. This just
the default method, though it should work for most cases. Each other
configuration class may have their own method if need be.

This statement uses a fair bit of basic Unicode characters mostly
for ease of printing and to reduce confusion.

\end{fulllineitems}

\index{read\_from\_file() (IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig method)@\spxentry{read\_from\_file()}\spxextra{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig.read_from_file}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read\_from\_file}}}{\emph{file\_name}}{}
Wrapper function around configuration file reading.

Reads and assigns a file IfA Smeargle configuration class to this
current class. See \sphinxcode{\sphinxupquote{read\_config\_file}} for more information on
file reading.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The path and name of the file that contains the configuration
class. Must have the extension \sphinxcode{\sphinxupquote{.ifaspkl}}. If \sphinxcode{\sphinxupquote{file\_name}}
is None, then nothing happens.

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_to\_file() (IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig method)@\spxentry{write\_to\_file()}\spxextra{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig.write_to_file}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write\_to\_file}}}{\emph{file\_name}, \emph{overwrite=False}, \emph{protocol=4}}{}
Wrapper function around configuration file writing.

Writes the configuration class to a pickle file. See
\sphinxcode{\sphinxupquote{write\_config\_file}} for more information.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{config\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{Configuration class}}) \textendash{} The configuration class that is going to be saved as a file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The name of the configuration class. The extension \sphinxcode{\sphinxupquote{.ifaspkl}}
is automatically applied. This denotes a Python pickle file from
IfA-Smeargle.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{overwrite}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} If true, the writing of the configuration class will overwrite any
existing file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{protocol}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The pickling protocol value for the pickling function.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file module}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BravoConfig_file:module-IfA_Smeargle.yankee.configuration_classes.BravoConfig_file}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BravoConfig_file:ifa-smeargle-yankee-configuration-classes-bravoconfig-file-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BravoConfig_file::doc}}\index{IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file (module)@\spxentry{IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file}\spxextra{module}}\index{BravoConfig (class in IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file)@\spxentry{BravoConfig}\spxextra{class in IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BravoConfig_file:IfA_Smeargle.yankee.configuration_classes.BravoConfig_file.BravoConfig}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file.}}\sphinxbfcode{\sphinxupquote{BravoConfig}}}{\emph{file\_name=None}}{}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig}}}}}

This is the configuration class of the BRAVO line.

The BRAVO line is mostly responsible for gathering the data from the
raw output of the detector and processing it in a form that the later
lines can use.

By default, all of the entries in the configurations are empty. Moreover,
each configuration attribute only contains the required entries. Optional
entries may be added at user discretion (see documentation for such
entries).

\begin{sphinxadmonition}{note}{Note:}
All built-in functions of the configuration classes are inherited from the
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseConfig}}}}}
class.

Configuration classes such as this one is generally wrapped within the
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:IfA_Smeargle.yankee.yankee_main.SmeargleConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SmeargleConfig}}}}} class.
\end{sphinxadmonition}
\index{detector\_name (IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file.BravoConfig attribute)@\spxentry{detector\_name}\spxextra{IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file.BravoConfig attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BravoConfig_file:IfA_Smeargle.yankee.configuration_classes.BravoConfig_file.BravoConfig.detector_name}}\pysigline{\sphinxbfcode{\sphinxupquote{detector\_name}}}
The name of the detector that is being processed.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dictionary or string

\end{description}\end{quote}

\end{fulllineitems}

\index{voltpat\_rename\_config (IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file.BravoConfig attribute)@\spxentry{voltpat\_rename\_config}\spxextra{IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file.BravoConfig attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BravoConfig_file:IfA_Smeargle.yankee.configuration_classes.BravoConfig_file.BravoConfig.voltpat_rename_config}}\pysigline{\sphinxbfcode{\sphinxupquote{voltpat\_rename\_config}}}
These are the parameters fed into \sphinxcode{\sphinxupquote{voltage\_pattern\_rename\_fits}}
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{avg\_endpts\_config (IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file.BravoConfig attribute)@\spxentry{avg\_endpts\_config}\spxextra{IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file.BravoConfig attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BravoConfig_file:IfA_Smeargle.yankee.configuration_classes.BravoConfig_file.BravoConfig.avg_endpts_config}}\pysigline{\sphinxbfcode{\sphinxupquote{avg\_endpts\_config}}}
These are the parameters fed into \sphinxcode{\sphinxupquote{average\_endpoints}}.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dictionary

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{IfA\_Smeargle.yankee.configuration\_classes.EchoConfig\_file module}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.EchoConfig_file:module-IfA_Smeargle.yankee.configuration_classes.EchoConfig_file}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.EchoConfig_file:ifa-smeargle-yankee-configuration-classes-echoconfig-file-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.EchoConfig_file::doc}}\index{IfA\_Smeargle.yankee.configuration\_classes.EchoConfig\_file (module)@\spxentry{IfA\_Smeargle.yankee.configuration\_classes.EchoConfig\_file}\spxextra{module}}\index{EchoConfig (class in IfA\_Smeargle.yankee.configuration\_classes.EchoConfig\_file)@\spxentry{EchoConfig}\spxextra{class in IfA\_Smeargle.yankee.configuration\_classes.EchoConfig\_file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.EchoConfig_file:IfA_Smeargle.yankee.configuration_classes.EchoConfig_file.EchoConfig}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.EchoConfig\_file.}}\sphinxbfcode{\sphinxupquote{EchoConfig}}}{\emph{file\_name=None}}{}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig}}}}}

This is the configuration class of the ECHO line.

The ECHO line is mostly for masking techniques. Each attribute in this
class is a dictionary entry that contains the parameters for these
masking/filtering functions.

By default, all of the entries in the configurations are empty.
Moreover, each configuration attribute only contains the required
entries. Optional entries may be added at user discretion (see
documentation for such entries).

\begin{sphinxadmonition}{note}{Note:}
All built-in functions of the configuration classes are inherited from the
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseConfig}}}}}
class.

Configuration classes such as this one is generally wrapped within the
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:IfA_Smeargle.yankee.yankee_main.SmeargleConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SmeargleConfig}}}}} class.
\end{sphinxadmonition}
\index{echo010\_config (IfA\_Smeargle.yankee.configuration\_classes.EchoConfig\_file.EchoConfig attribute)@\spxentry{echo010\_config}\spxextra{IfA\_Smeargle.yankee.configuration\_classes.EchoConfig\_file.EchoConfig attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.EchoConfig_file:IfA_Smeargle.yankee.configuration_classes.EchoConfig_file.EchoConfig.echo010_config}}\pysigline{\sphinxbfcode{\sphinxupquote{echo010\_config}}}
The configuration parameters for the ECHO-010 mask.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{echo120\_config (IfA\_Smeargle.yankee.configuration\_classes.EchoConfig\_file.EchoConfig attribute)@\spxentry{echo120\_config}\spxextra{IfA\_Smeargle.yankee.configuration\_classes.EchoConfig\_file.EchoConfig attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.EchoConfig_file:IfA_Smeargle.yankee.configuration_classes.EchoConfig_file.EchoConfig.echo120_config}}\pysigline{\sphinxbfcode{\sphinxupquote{echo120\_config}}}
The configuration parameters for the ECHO-120 mask.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dictionary

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{etc...etc...etc...}}}
\end{fulllineitems}


\end{fulllineitems}



\subparagraph{IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file module}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.OscarConfig_file:module-IfA_Smeargle.yankee.configuration_classes.OscarConfig_file}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.OscarConfig_file:ifa-smeargle-yankee-configuration-classes-oscarconfig-file-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.OscarConfig_file::doc}}\index{IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file (module)@\spxentry{IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file}\spxextra{module}}\index{OscarConfig (class in IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file)@\spxentry{OscarConfig}\spxextra{class in IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.OscarConfig_file:IfA_Smeargle.yankee.configuration_classes.OscarConfig_file.OscarConfig}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file.}}\sphinxbfcode{\sphinxupquote{OscarConfig}}}{\emph{file\_name=None}}{}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig}}}}}

This is the configuration class of the OSCAR line.

The OSCAR line is mostly responsible for creating good histograms and
heat-maps of pixels and their value for further analysis.

By default, all of the entries in the configurations are empty. Moreover,
each configuration attribute only contains the required entries. Optional
entries may be added at user discretion (see documentation for such
entries).

\begin{sphinxadmonition}{note}{Note:}
All built-in functions of the configuration classes are inherited from the
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseConfig}}}}}
class.

Configuration classes such as this one is generally wrapped within the
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:IfA_Smeargle.yankee.yankee_main.SmeargleConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SmeargleConfig}}}}} class.
\end{sphinxadmonition}
\index{heatmap\_config (IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file.OscarConfig attribute)@\spxentry{heatmap\_config}\spxextra{IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file.OscarConfig attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.OscarConfig_file:IfA_Smeargle.yankee.configuration_classes.OscarConfig_file.OscarConfig.heatmap_config}}\pysigline{\sphinxbfcode{\sphinxupquote{heatmap\_config}}}
These are the parameters which are fed into
\sphinxcode{\sphinxupquote{plot\_array\_heatmap\_image}}
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{histogram\_config (IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file.OscarConfig attribute)@\spxentry{histogram\_config}\spxextra{IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file.OscarConfig attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.OscarConfig_file:IfA_Smeargle.yankee.configuration_classes.OscarConfig_file.OscarConfig.histogram_config}}\pysigline{\sphinxbfcode{\sphinxupquote{histogram\_config}}}
These are the parameters which are fed into
\sphinxcode{\sphinxupquote{plot\_array\_histogram}}
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{heathist\_config (IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file.OscarConfig attribute)@\spxentry{heathist\_config}\spxextra{IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file.OscarConfig attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.OscarConfig_file:IfA_Smeargle.yankee.configuration_classes.OscarConfig_file.OscarConfig.heathist_config}}\pysigline{\sphinxbfcode{\sphinxupquote{heathist\_config}}}
These are the parameters which are fed into
\sphinxcode{\sphinxupquote{plot\_single\_heatmap\_and\_histogram}}
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dictionary

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{IfA\_Smeargle.yankee.configuration\_classes.YankeeConfig\_file module}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.YankeeConfig_file:module-IfA_Smeargle.yankee.configuration_classes.YankeeConfig_file}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.YankeeConfig_file:ifa-smeargle-yankee-configuration-classes-yankeeconfig-file-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.YankeeConfig_file::doc}}\index{IfA\_Smeargle.yankee.configuration\_classes.YankeeConfig\_file (module)@\spxentry{IfA\_Smeargle.yankee.configuration\_classes.YankeeConfig\_file}\spxextra{module}}\index{YankeeConfig (class in IfA\_Smeargle.yankee.configuration\_classes.YankeeConfig\_file)@\spxentry{YankeeConfig}\spxextra{class in IfA\_Smeargle.yankee.configuration\_classes.YankeeConfig\_file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.YankeeConfig_file:IfA_Smeargle.yankee.configuration_classes.YankeeConfig_file.YankeeConfig}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.YankeeConfig\_file.}}\sphinxbfcode{\sphinxupquote{YankeeConfig}}}{\emph{file\_name=None}}{}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig}}}}}

This is the configuration class of the YANKEE line.

The YANKEE line is mostly responsible for holding, storing, and reading
of configuration files and classes that dictate the rest  of the module’s
behavior.

By default, all of the entries in the configurations are empty. Moreover,
each configuration attribute only contains the required entries. Optional
entries may be added at user  discretion (see documentation for such
entries).

\begin{sphinxadmonition}{note}{Note:}
All built-in functions of the configuration classes are inherited from the
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseConfig}}}}}
class.

Configuration classes such as this one is generally wrapped within the
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:IfA_Smeargle.yankee.yankee_main.SmeargleConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SmeargleConfig}}}}} class.
\end{sphinxadmonition}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.yankee.configuration\_classes.ZuluConfig\_file module}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.ZuluConfig_file:module-IfA_Smeargle.yankee.configuration_classes.ZuluConfig_file}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.ZuluConfig_file:ifa-smeargle-yankee-configuration-classes-zuluconfig-file-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.ZuluConfig_file::doc}}\index{IfA\_Smeargle.yankee.configuration\_classes.ZuluConfig\_file (module)@\spxentry{IfA\_Smeargle.yankee.configuration\_classes.ZuluConfig\_file}\spxextra{module}}\index{ZuluConfig (class in IfA\_Smeargle.yankee.configuration\_classes.ZuluConfig\_file)@\spxentry{ZuluConfig}\spxextra{class in IfA\_Smeargle.yankee.configuration\_classes.ZuluConfig\_file}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.ZuluConfig_file:IfA_Smeargle.yankee.configuration_classes.ZuluConfig_file.ZuluConfig}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.ZuluConfig\_file.}}\sphinxbfcode{\sphinxupquote{ZuluConfig}}}{\emph{file\_name=None}}{}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig}}}}}

This is the configuration class of the ZULU line.

The ZULU line is responsible for collecting all functions for each
detector analysis line and grouping them into one method.

By default, all of the entries in the configurations are empty. Moreover,
each configuration attribute only contains the required entries. Optional
entries may be added at user discretion (see documentation for such
entries).

\begin{sphinxadmonition}{note}{Note:}
All built-in functions of the configuration classes are inherited from the
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseConfig}}}}}
class.

Configuration classes such as this one is generally wrapped within the
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:IfA_Smeargle.yankee.yankee_main.SmeargleConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SmeargleConfig}}}}} class.
\end{sphinxadmonition}

\end{fulllineitems}



\subparagraph{Module contents}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes:module-IfA_Smeargle.yankee.configuration_classes}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes:module-contents}}\index{IfA\_Smeargle.yankee.configuration\_classes (module)@\spxentry{IfA\_Smeargle.yankee.configuration\_classes}\spxextra{module}}

\paragraph{Submodules}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee:submodules}}

\subparagraph{IfA\_Smeargle.yankee.yankee\_functions module}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_functions:module-IfA_Smeargle.yankee.yankee_functions}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_functions:ifa-smeargle-yankee-yankee-functions-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_functions::doc}}\index{IfA\_Smeargle.yankee.yankee\_functions (module)@\spxentry{IfA\_Smeargle.yankee.yankee\_functions}\spxextra{module}}
These functions just provide a nice and easy place to put functions whose
purpose is to allow for the proper reading of different possible arrangements
of the configuration parameters.
\index{configuration\_factory\_function() (in module IfA\_Smeargle.yankee.yankee\_functions)@\spxentry{configuration\_factory\_function()}\spxextra{in module IfA\_Smeargle.yankee.yankee\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_functions:IfA_Smeargle.yankee.yankee_functions.configuration_factory_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.yankee\_functions.}}\sphinxbfcode{\sphinxupquote{configuration\_factory\_function}}}{\emph{desired\_class}, \emph{file\_name=None}, \emph{silent=False}}{}
A function that will always open or load the proper configuration
class.

This is considered the safest method of loading a configuration class
from file. This function returns the desired configuration file if it is
contained within the file; else, it returns a blank configuration.

Please note, this does not write the configuration class to file, ever.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{desired\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{Configuration class}}) \textendash{} The desired configuration class type that should be extracted from the
file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The name of the configuration file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{silent}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Turn off all warnings and information sent by this function and
functions below it.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{config\_class} \textendash{} The desired configuration class instance.

\item[{Return type}] \leavevmode
Configuration class

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_proper\_configuration\_class() (in module IfA\_Smeargle.yankee.yankee\_functions)@\spxentry{extract\_proper\_configuration\_class()}\spxextra{in module IfA\_Smeargle.yankee.yankee\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_functions:IfA_Smeargle.yankee.yankee_functions.extract_proper_configuration_class}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.yankee\_functions.}}\sphinxbfcode{\sphinxupquote{extract\_proper\_configuration\_class}}}{\emph{configuration\_class}, \emph{desired\_class}, \emph{deep\_copy=False}}{}
This function extracts the proper configuration class from a
collection of configuration classes.

The whole point of this function is to retain the flexibility and ease
of using differing configuration classes and the structure of the
configuration classes themselves.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{configuration\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any BaseConfig based class}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The main configuration class that should contain the desired class.
It may also be a file name.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{desired\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any BaseConfig based class execpt for BaseConfig}}) \textendash{} The desired class.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{deep\_copy}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If a deep copy of the class is desired, then set to True.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{extracted\_class} \textendash{} A copy of the desired configuration class.

\item[{Return type}] \leavevmode
Any BaseConfig based class (same class as desired class)

\end{description}\end{quote}

\end{fulllineitems}

\index{fast\_forward\_configuration\_class() (in module IfA\_Smeargle.yankee.yankee\_functions)@\spxentry{fast\_forward\_configuration\_class()}\spxextra{in module IfA\_Smeargle.yankee.yankee\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_functions:IfA_Smeargle.yankee.yankee_functions.fast_forward_configuration_class}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.yankee\_functions.}}\sphinxbfcode{\sphinxupquote{fast\_forward\_configuration\_class}}}{\emph{configuration\_class}}{}
This functions updates the configuration class to the most compatible
version.

One of the byproducts of how the YANKEE line is coded is that
configuration files made in previous versions of IfA-Smeargle will not
work by default. This function fixes that, returning an updated
configuration class that can be used with the current installed version.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{configuration\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{Configuration Class}}) \textendash{} The configuration class that is to be updated and fast-forwarded into
its future.

\item[{Returns}] \leavevmode
\sphinxstylestrong{updated\_configuration\_class} \textendash{} The configuration class that should be updated and compatible with
the current version.

\item[{Return type}] \leavevmode
Configuration Class

\end{description}\end{quote}

\end{fulllineitems}

\index{overwrite\_configuration\_class() (in module IfA\_Smeargle.yankee.yankee\_functions)@\spxentry{overwrite\_configuration\_class()}\spxextra{in module IfA\_Smeargle.yankee.yankee\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_functions:IfA_Smeargle.yankee.yankee_functions.overwrite_configuration_class}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.yankee\_functions.}}\sphinxbfcode{\sphinxupquote{overwrite\_configuration\_class}}}{\emph{inferior\_class}, \emph{superior\_class}}{}
This function combines two configuration classes by overwriting some
parts with a more recent class.

This function allows for two configuration classes to be combined. Where
the two configuration classes collide, the \sphinxcode{\sphinxupquote{superior}} class will
overwrite the \sphinxcode{\sphinxupquote{inferior}} class objects.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inferior\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{Configuration Class}}) \textendash{} The configuration class that is to be updated and conflicting
attributes be overwritten.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{superior\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{Configuration Class}}) \textendash{} The configuration class that is to be added to and overwrite any
conflicts to the other class.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{combined\_configuration\_class} \textendash{} The configuration class that should be the correct combination of
both classes.

\item[{Return type}] \leavevmode
Configuration Class

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_config\_file() (in module IfA\_Smeargle.yankee.yankee\_functions)@\spxentry{read\_config\_file()}\spxextra{in module IfA\_Smeargle.yankee.yankee\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_functions:IfA_Smeargle.yankee.yankee_functions.read_config_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.yankee\_functions.}}\sphinxbfcode{\sphinxupquote{read\_config\_file}}}{\emph{file\_name}}{}
Function to read a specific configuration class from a normal file.

As the entire module more or less depends on configuration classes. It is
important to be able to save, copy, and reuse configuration classes.
Therefore, this allows pre-made/saved configuration files to be read from
a file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The path and name of the file that contains the configuration class.
Must have the extension \sphinxcode{\sphinxupquote{.ifaspkl}}

\item[{Returns}] \leavevmode
\sphinxstylestrong{config\_class} \textendash{} The configuration class stored in the file.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:IfA_Smeargle.yankee.yankee_main.SmeargleConfig}]{\sphinxcrossref{SmeargleConfig}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_config\_file() (in module IfA\_Smeargle.yankee.yankee\_functions)@\spxentry{write\_config\_file()}\spxextra{in module IfA\_Smeargle.yankee.yankee\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_functions:IfA_Smeargle.yankee.yankee_functions.write_config_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.yankee\_functions.}}\sphinxbfcode{\sphinxupquote{write\_config\_file}}}{\emph{config\_class}, \emph{file\_name}, \emph{overwrite=False}, \emph{protocol=4}}{}
Function to write a specific configuration class to a normal file.

As the entire module more or less depends on configuration classes. It
is important to be able to save, copy, and reuse configuration classes.
Therefore, this allows configuration files to be written to file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{config\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{Configuration class}}) \textendash{} The configuration class that is going to be saved as a file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The name of the configuration class. The extension \sphinxcode{\sphinxupquote{.ifaspkl}}
is automatically applied. This denotes a Python pickle file from
IfA-Smeargle.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{overwrite}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}) \textendash{} If true, the writing of the configuration class will overwrite any
existing file.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{protocol}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The pickling protocol value for the pickling function.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{IfA\_Smeargle.yankee.yankee\_main module}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:module-IfA_Smeargle.yankee.yankee_main}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:ifa-smeargle-yankee-yankee-main-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main::doc}}\index{IfA\_Smeargle.yankee.yankee\_main (module)@\spxentry{IfA\_Smeargle.yankee.yankee\_main}\spxextra{module}}
The purpose of this line is for the storage of configuration elements that are used on all
other lines. The configuration of the entire Smeargle module is read, written, and used from
here.

Though technically a meta-line, as it is a full line in itself, it is not considered to fit
in the meta functionality.
\index{SmeargleConfig (class in IfA\_Smeargle.yankee.yankee\_main)@\spxentry{SmeargleConfig}\spxextra{class in IfA\_Smeargle.yankee.yankee\_main}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.yankee.yankee_main:IfA_Smeargle.yankee.yankee_main.SmeargleConfig}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.yankee\_main.}}\sphinxbfcode{\sphinxupquote{SmeargleConfig}}}{\emph{file\_name=None}}{}
Bases: {\hyperref[\detokenize{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:IfA_Smeargle.yankee.configuration_classes.BaseConfig_file.BaseConfig}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file.BaseConfig}}}}}

Configuration class of the entire Smeargle pipeline and other
properties.

Each different array configuration must have its own reduction method.
The purpose of this class is to be an organized collection of ALL
configuration options possible. That is, this class is read by the main
pipeline and all other functions are created.

Within each argument exists another configuration class specific to each
of the Smeargle lines. They are defined in their appropriate files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{BravoConfig}} (\sphinxstyleliteralemphasis{\sphinxupquote{Configuration class}}) \textendash{} The configuration class for the BRAVO line.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{EchoConfig}} (\sphinxstyleliteralemphasis{\sphinxupquote{Configuration class}}) \textendash{} The configuration class for the ECHO line.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{OscarConfig}} (\sphinxstyleliteralemphasis{\sphinxupquote{Configuration class}}) \textendash{} The configuration class for the OSCAR line.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{YankeeConfig}} (\sphinxstyleliteralemphasis{\sphinxupquote{Configuration class}}) \textendash{} The configuration class for the YANKEE line.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{BaseConfig}} (\sphinxstyleliteralemphasis{\sphinxupquote{Configuration class}}) \textendash{} The base configuration class, should generally not be used to store
parameters.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{python_docstrings/IfA_Smeargle.yankee:module-IfA_Smeargle.yankee}}\label{\detokenize{python_docstrings/IfA_Smeargle.yankee:module-contents}}\index{IfA\_Smeargle.yankee (module)@\spxentry{IfA\_Smeargle.yankee}\spxextra{module}}

\subsubsection{IfA\_Smeargle.zulu package}
\label{\detokenize{python_docstrings/IfA_Smeargle.zulu:ifa-smeargle-zulu-package}}\label{\detokenize{python_docstrings/IfA_Smeargle.zulu::doc}}

\paragraph{Subpackages}
\label{\detokenize{python_docstrings/IfA_Smeargle.zulu:subpackages}}

\subparagraph{IfA\_Smeargle.zulu.detector\_pipelines package}
\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.detector_pipelines:ifa-smeargle-zulu-detector-pipelines-package}}\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.detector_pipelines::doc}}

\subparagraph{Submodules}
\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.detector_pipelines:submodules}}

\subparagraph{IfA\_Smeargle.zulu.detector\_pipelines.saphira\_pipeline module}
\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.detector_pipelines.saphira_pipeline:module-IfA_Smeargle.zulu.detector_pipelines.saphira_pipeline}}\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.detector_pipelines.saphira_pipeline:ifa-smeargle-zulu-detector-pipelines-saphira-pipeline-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.detector_pipelines.saphira_pipeline::doc}}\index{IfA\_Smeargle.zulu.detector\_pipelines.saphira\_pipeline (module)@\spxentry{IfA\_Smeargle.zulu.detector\_pipelines.saphira\_pipeline}\spxextra{module}}
This is the entire reduction method for the Saphria based infrared arrays.
\index{SA201907281826\_reduction\_pipeline() (in module IfA\_Smeargle.zulu.detector\_pipelines.saphira\_pipeline)@\spxentry{SA201907281826\_reduction\_pipeline()}\spxextra{in module IfA\_Smeargle.zulu.detector\_pipelines.saphira\_pipeline}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.detector_pipelines.saphira_pipeline:IfA_Smeargle.zulu.detector_pipelines.saphira_pipeline.SA201907281826_reduction_pipeline}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.zulu.detector\_pipelines.saphira\_pipeline.}}\sphinxbfcode{\sphinxupquote{SA201907281826\_reduction\_pipeline}}}{\emph{data\_directory}, \emph{configuration\_class}}{}
This function is the reduction pipeline instructed on 2019-07-28,
18:26.

This reduction line differs from the main branch significantly enough to
warrant itself its own special function. Its variants are also listed here.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The data directory straight out of the SAPHIRA array. Data
preprocessing is internally handled.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{configuration\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{SmeargleConfig class}}) \textendash{} The configuration class/options that go along with this reduction
script. Must be a SmeargleConfig class instance. Default
configurations are stored in the Configuration\_Archive

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{saphira\_reduction\_pipeline() (in module IfA\_Smeargle.zulu.detector\_pipelines.saphira\_pipeline)@\spxentry{saphira\_reduction\_pipeline()}\spxextra{in module IfA\_Smeargle.zulu.detector\_pipelines.saphira\_pipeline}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.detector_pipelines.saphira_pipeline:IfA_Smeargle.zulu.detector_pipelines.saphira_pipeline.saphira_reduction_pipeline}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.zulu.detector\_pipelines.saphira\_pipeline.}}\sphinxbfcode{\sphinxupquote{saphira\_reduction\_pipeline}}}{\emph{data\_directory}, \emph{configuration\_class}}{}
This is the entire reduction and analysis pipeline for the SAPHRIA
arrays.

This is the default reduction pipeline for the SAPHIRA array. The
“outputs” are written to file(s) and arranged in their own directory
instead of a Python output, mostly because of the sheer number of outputs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The data directory straight out of the SAPHIRA array. Data
preprocessing is internally handled.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{configuration\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{SmeargleConfig class}}) \textendash{} The configuration class/options that go along with this reduction
script. Must be a SmeargleConfig class instance.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{Module contents}
\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.detector_pipelines:module-IfA_Smeargle.zulu.detector_pipelines}}\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.detector_pipelines:module-contents}}\index{IfA\_Smeargle.zulu.detector\_pipelines (module)@\spxentry{IfA\_Smeargle.zulu.detector\_pipelines}\spxextra{module}}
The reduction of the arrays should not generally call the upper lines.
Each line should be called within a Zulu function, allowing for the
consistency and ease of usage of the IfA Smeargle module. Changes should
only be applied to the configuration classes.

Slight, required modifications to the default lines are their own separate
functions, contained within the file of the detector that they apply to.


\paragraph{Submodules}
\label{\detokenize{python_docstrings/IfA_Smeargle.zulu:submodules}}

\subparagraph{IfA\_Smeargle.zulu.zulu\_main module}
\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.zulu_main:module-IfA_Smeargle.zulu.zulu_main}}\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.zulu_main:ifa-smeargle-zulu-zulu-main-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.zulu.zulu_main::doc}}\index{IfA\_Smeargle.zulu.zulu\_main (module)@\spxentry{IfA\_Smeargle.zulu.zulu\_main}\spxextra{module}}
The ZULU line is the final cumulation of all other lines, in a way, it is
the script that dictates how the data should be manipulated. Each array
type has its own functional line, while each subset of these arrays should
contain their own configuration file (from Yankee).

Each functional line is contained within their own file.

The reduction of the arrays should not generally call the upper lines.
Each line should be called within a Zulu function, allowing for the
consistency and ease of usage of the IfA Smeargle module. Changes should
only be applied to the configuration classes.


\paragraph{Module contents}
\label{\detokenize{python_docstrings/IfA_Smeargle.zulu:module-IfA_Smeargle.zulu}}\label{\detokenize{python_docstrings/IfA_Smeargle.zulu:module-contents}}\index{IfA\_Smeargle.zulu (module)@\spxentry{IfA\_Smeargle.zulu}\spxextra{module}}

\subsection{Submodules}
\label{\detokenize{python_docstrings/IfA_Smeargle:submodules}}

\subsubsection{IfA\_Smeargle.ifas\_execute module}
\label{\detokenize{python_docstrings/IfA_Smeargle.ifas_execute:module-IfA_Smeargle.ifas_execute}}\label{\detokenize{python_docstrings/IfA_Smeargle.ifas_execute:ifa-smeargle-ifas-execute-module}}\label{\detokenize{python_docstrings/IfA_Smeargle.ifas_execute::doc}}\index{IfA\_Smeargle.ifas\_execute (module)@\spxentry{IfA\_Smeargle.ifas\_execute}\spxextra{module}}\index{execute\_ifas\_smeargle() (in module IfA\_Smeargle.ifas\_execute)@\spxentry{execute\_ifas\_smeargle()}\spxextra{in module IfA\_Smeargle.ifas\_execute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python_docstrings/IfA_Smeargle.ifas_execute:IfA_Smeargle.ifas_execute.execute_ifas_smeargle}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{IfA\_Smeargle.ifas\_execute.}}\sphinxbfcode{\sphinxupquote{execute\_ifas\_smeargle}}}{\emph{pipeline\_name}, \emph{data\_directory}, \emph{config\_class\_path}, \emph{silent=False}}{}
This takes the input from an argparser and executes the proper
pipeline.

This function takes string information and parses and executes the input
to the best of the ability of this module. This function cannot be called
unless it via the command-line execution route.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pipeline\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The name of the data reduction pipeline that will be used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The path to the data, specifically where the data is all stored in.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{config\_class\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The file path (including the file) that describes where the
configuration class lies.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{silent}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Turn off all warnings and information sent by this function and
functions below it.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{pipeline\_results} \textendash{} Returns exactly what the pipeline function would have returned.

\item[{Return type}] \leavevmode
unknown

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Module contents}
\label{\detokenize{python_docstrings/IfA_Smeargle:module-IfA_Smeargle}}\label{\detokenize{python_docstrings/IfA_Smeargle:module-contents}}\index{IfA\_Smeargle (module)@\spxentry{IfA\_Smeargle}\spxextra{module}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{i}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle:\detokenize{module-IfA_Smeargle}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.bravo}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.bravo:\detokenize{module-IfA_Smeargle.bravo}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.bravo.archiving}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.bravo.archiving:\detokenize{module-IfA_Smeargle.bravo.archiving}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.bravo.averaging}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.bravo.averaging:\detokenize{module-IfA_Smeargle.bravo.averaging}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.bravo.bravo\_main}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.bravo.bravo_main:\detokenize{module-IfA_Smeargle.bravo.bravo_main}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.bravo.renaming}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.bravo.renaming:\detokenize{module-IfA_Smeargle.bravo.renaming}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.echo}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.echo:\detokenize{module-IfA_Smeargle.echo}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.echo.echo\_functions}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.echo.echo_functions:\detokenize{module-IfA_Smeargle.echo.echo_functions}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.echo.echo\_main}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.echo.echo_main:\detokenize{module-IfA_Smeargle.echo.echo_main}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.echo.masks}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.echo.masks:\detokenize{module-IfA_Smeargle.echo.masks}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.echo.masks.masks\_echo000}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.echo.masks.masks_echo000:\detokenize{module-IfA_Smeargle.echo.masks.masks_echo000}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.echo.masks.masks\_echo100}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.echo.masks.masks_echo100:\detokenize{module-IfA_Smeargle.echo.masks.masks_echo100}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.echo.masks.masks\_echo200}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.echo.masks.masks_echo200:\detokenize{module-IfA_Smeargle.echo.masks.masks_echo200}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.echo.masks.masks\_echo300}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.echo.masks.masks_echo300:\detokenize{module-IfA_Smeargle.echo.masks.masks_echo300}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.ifas\_execute}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.ifas_execute:\detokenize{module-IfA_Smeargle.ifas_execute}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.meta}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.meta:\detokenize{module-IfA_Smeargle.meta}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.meta.configuration}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.meta.configuration:\detokenize{module-IfA_Smeargle.meta.configuration}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.meta.errors}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.meta.errors:\detokenize{module-IfA_Smeargle.meta.errors}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.meta.fits\_and\_arrays}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.meta.fits_and_arrays:\detokenize{module-IfA_Smeargle.meta.fits_and_arrays}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.meta.meta\_main}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.meta.meta_main:\detokenize{module-IfA_Smeargle.meta.meta_main}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.meta.modeling\_and\_fitting}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.meta.modeling_and_fitting:\detokenize{module-IfA_Smeargle.meta.modeling_and_fitting}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.meta.plotting}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.meta.plotting:\detokenize{module-IfA_Smeargle.meta.plotting}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.oscar}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.oscar:\detokenize{module-IfA_Smeargle.oscar}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.oscar.heatmaps}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.oscar.heatmaps:\detokenize{module-IfA_Smeargle.oscar.heatmaps}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.oscar.histograms}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.oscar.histograms:\detokenize{module-IfA_Smeargle.oscar.histograms}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.oscar.multi\_figure}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.oscar.multi_figure:\detokenize{module-IfA_Smeargle.oscar.multi_figure}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.oscar.oscar\_functions}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.oscar.oscar_functions:\detokenize{module-IfA_Smeargle.oscar.oscar_functions}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.oscar.oscar\_main}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.oscar.oscar_main:\detokenize{module-IfA_Smeargle.oscar.oscar_main}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.yankee}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.yankee:\detokenize{module-IfA_Smeargle.yankee}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.yankee.configuration\_classes}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.yankee.configuration_classes:\detokenize{module-IfA_Smeargle.yankee.configuration_classes}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.yankee.configuration\_classes.BaseConfig\_file}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BaseConfig_file:\detokenize{module-IfA_Smeargle.yankee.configuration_classes.BaseConfig_file}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.yankee.configuration\_classes.BravoConfig\_file}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.yankee.configuration_classes.BravoConfig_file:\detokenize{module-IfA_Smeargle.yankee.configuration_classes.BravoConfig_file}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.yankee.configuration\_classes.EchoConfig\_file}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.yankee.configuration_classes.EchoConfig_file:\detokenize{module-IfA_Smeargle.yankee.configuration_classes.EchoConfig_file}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.yankee.configuration\_classes.OscarConfig\_file}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.yankee.configuration_classes.OscarConfig_file:\detokenize{module-IfA_Smeargle.yankee.configuration_classes.OscarConfig_file}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.yankee.configuration\_classes.YankeeConfig\_file}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.yankee.configuration_classes.YankeeConfig_file:\detokenize{module-IfA_Smeargle.yankee.configuration_classes.YankeeConfig_file}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.yankee.configuration\_classes.ZuluConfig\_file}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.yankee.configuration_classes.ZuluConfig_file:\detokenize{module-IfA_Smeargle.yankee.configuration_classes.ZuluConfig_file}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.yankee.yankee\_functions}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.yankee.yankee_functions:\detokenize{module-IfA_Smeargle.yankee.yankee_functions}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.yankee.yankee\_main}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.yankee.yankee_main:\detokenize{module-IfA_Smeargle.yankee.yankee_main}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.zulu}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.zulu:\detokenize{module-IfA_Smeargle.zulu}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.zulu.detector\_pipelines}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.zulu.detector_pipelines:\detokenize{module-IfA_Smeargle.zulu.detector_pipelines}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.zulu.detector\_pipelines.saphira\_pipeline}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.zulu.detector_pipelines.saphira_pipeline:\detokenize{module-IfA_Smeargle.zulu.detector_pipelines.saphira_pipeline}}
\item\relax\sphinxstyleindexentry{IfA\_Smeargle.zulu.zulu\_main}\sphinxstyleindexpageref{python_docstrings/IfA_Smeargle.zulu.zulu_main:\detokenize{module-IfA_Smeargle.zulu.zulu_main}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}